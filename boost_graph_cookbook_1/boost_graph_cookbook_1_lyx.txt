%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting the vertices' out degree}
\label{subsec:get_vertex_out_degrees}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's measure the out degree of all vertices in a graph! 

The out degree of a vertex is the number of edges that originate at it.

The number of connections is called the \verb;degree; of the vertex.
There are three types of degrees:

\begin{itemize}
  \item in degree: the number of incoming connections, 
    using \verb;in_degree; \index{in_degree}
    (not \verb;boost::in_degree; \index{boost::in_degree does not exist} )
  \item out degree: the number of outgoing connections, 
    using \verb;out_degree; \index{out_degree}
    (not \verb;boost::out_degree; \index{boost::out_degree does not exist})
  \item degree: sum of the in degree and out degree, 
    using \verb;degree; \index{idegree}
    (not \verb;boost::degree; \index{boost::degree does not exist})
\end{itemize}

Listing \ref{lst:get_vertex_out_degrees}
shows how to obtain these:

\lstinputlisting[
  caption = Get the vertices' out degrees,
  label = lst:get_vertex_out_degrees
]{get_vertex_out_degrees.impl}
\index{Get vertex out degrees}

The structure of this algorithm is similar to 
\verb;get_vertex_descriptors; (algorithm \ref{lst:get_vertex_descriptors}), 
except that the out degrees from the vertex descriptors are stored.
The out degree of a vertex iterator is obtained from 
the function \verb;out_degree; \index{out_degree}
(not boost::out_degree \index{boost::out_degree does not exist}!).
 
Albeit that the $K_{2}$
graph and the two-state Markov chain are rather simple, we can use it to
demonstrate \verb;get_vertex_out_degrees; on, as shown in algorithm 
\ref{lst:get_vertex_out_degrees_demo}

.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_vertex_out_degrees_demo.impl}

Demonstration of the \verb;get_vertex_out_degrees; function
\label{lst:get_vertex_out_degrees_demo}

It is expected that 
$K_{2}$

 has one out-degree for every vertex, where the two-state Markov chain is
 expected to have two out-degrees per vertex.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$ Is there an edge between two vertices?}
\label{subsec:has_edge_between_vertices}

If you have two vertex descriptors, you can check if these are connected
 by an edge:

\lstinputlisting[
  caption = ,
  label = lst:
]{has_edge_between_vertices.impl}

Check if there exists an edge between two vertices
\index{Has edge between vertices}

\label{lst:has_edge_between_vertices}

This code uses the function \verb;edge;
\index{edge}

 (not boost::edge
\index{boost::edge does not exist}

: it returns a pair consisting of an edge descriptor and a boolean indicating
 if it is a valid edge descriptor.
 The boolean will be true if there exists an edge between the two vertices
 and false if not.

The demo shows that there is an edge between the two vertices of a 
$K_{2}$

 graph, but there are no self-loops (edges that original and end at the
 same vertex).

\lstinputlisting[
  caption = ,
  label = lst:
]{has_edge_between_vertices_demo.impl}

Demonstration of the \verb;has_edge_between_vertices; function
\label{lst:has_edge_between_vertices_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$ Get the edge between two vertices}
\label{subsec:get_edge_between_vertices}

If you have two vertex descriptors, you can use these to find the edge between
 them.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_edge_between_vertices.impl}

Get the edge between two vertices
\index{Get edge between vertices}

\label{lst:get_edge_between_vertices}

This code does assume that there is an edge between the two vertices.

The demo shows how to get the edge between two vertices, deleting it, and
 checking for success.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_edge_between_vertices_demo.impl}

Demonstration of the \verb;get_edge_between_vertices; function
\label{lst:get_edge_between_vertices_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$$\triangle$ Create a direct-neighbour subgraph from a vertex descriptor}
\label{subsec:create_direct_neighbour_subgraph}

Suppose you have a vertex of interest its vertex descriptor.
 Let's say you want to get a subgraph of that vertex and its direct neighbours
 only.
 This means that all vertices of that subgraph are adjacent vertices and
 that the edges go either from focal vertex to its neighbours, or from adjacent
 vertex to adjacent neighbour.

Here is the \verb;create_direct_neighbour_subgraph; code:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_direct_neighbour_subgraph.impl}

Get the direct-neighbour subgraph from a vertex descriptor
\index{Create direct-neighbour subgraph}

\label{lst:create_direct_neighbour_subgraph}

This demonstration code shows that the direct-neighbour graph of each vertex
 of a 
$K_{2}$

 graphs is ...
 a 
$K_{2}$

 graph!

\lstinputlisting[
  caption = ,
  label = lst:
]{create_direct_neighbour_subgraph_demo.impl}

Demo of the \verb;create_direct_neighbour_subgraph; function
\label{lst:create_direct_neighbour_subgraph_demo}

Note that this algorithm works on both undirected and directional graphs.
 If the graph is directional, only the out edges will be copied.
 To also copy the vertices connected with inward edges, use 
\ref{subsec:create_direct_neighbour_subgraph_including_in_edges}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$$\triangle$ Create a direct-neighbour subgraph from a vertex descriptor including inward edges}
\label{subsec:create_direct_neighbour_subgraph_including_in_edges}

Too bad, this algorithm does not work yet.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_direct_neighbour_subgraph_including_in_edges.impl}

Get the direct-neighbour subgraph from a vertex descriptor
\index{Create direct-neighbour subgraph_including_in_edges}

\label{lst:create_direct_neighbour_subgraph_including_in_edges}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$$\triangle$ Creating all direct-neighbour subgraphs from a graph without properties}
\label{subsec:create_all_direct_neighbour_subgraphs}

Using the previous function, it is easy to create all direct-neighbour subgraphs
 from a graph without properties:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_all_direct_neighbour_subgraphs.impl}

Create all direct-neighbour subgraphs from a graph without properties
\index{Create all direct-neighbour subgraphs}

\label{lst:create_all_direct_neighbour_subgraphs}

This demonstration code shows that all two direct-neighbour graphs of a
 
$K_{2}$

 graphs are ...
 
$K_{2}$

 graphs!

\lstinputlisting[
  caption = ,
  label = lst:
]{create_all_direct_neighbour_subgraphs_demo.impl}

Demo of the \verb;create_all_direct_neighbour_subgraphs; function
\label{lst:create_all_direct_neighbour_subgraphs_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$ Are two graphs isomorphic?}
\label{subsec:is_isomorphic}

You may want to check if two graphs are isomorphic.
 That is: if they have the same shape.

\lstinputlisting[
  caption = ,
  label = lst:
]{is_isomorphic.impl}

Check if two graphs are isomorphic
\index{Is isomorphic}

\label{lst:is_isomorphic}

This demonstration code shows that a 
$K_{3}$

 graph is not equivalent to a 3-vertices path graph:

\lstinputlisting[
  caption = ,
  label = lst:
]{is_isomorphic_demo.impl}

Demo of the \verb;is_isomorphic; function
\label{lst:is_isomorphic_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$$\triangle$ Count the number of connected components in an directed graph}
\label{subsec:count_directed_graph_connected_components}

A directed graph may consist out of two components, that are connected within
 each, but unconnected between them.
 Take for example, a graph of two isolated edges, with four vertices.
 

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
tikz 

\backslash
draw[thick] 

  (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 

    -> (5,2) node[draw=black,fill=white,shape=circle,text=white] {} 

    -> (3,4) node[draw=black,fill=white,shape=circle,text=white] {} 

    -> (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 

(6,0) node[draw=black,fill=white,shape=circle,text=white] {} 

    -> (10,2) node[draw=black,fill=white,shape=circle,text=white] {} 

    -> (8,4) node[draw=black,fill=white,shape=circle,text=white] {} 

    -> (6,0) node[draw=black,fill=white,shape=circle,text=white] {} 

;

Example of a directed graph with two components
\label{fig:count_directed_graph_connected_components}

This algorithm counts the number of connected components:

\lstinputlisting[
  caption = ,
  label = lst:
]{count_directed_graph_connected_components.impl}

Count the number of connected components
\index{Count connected components}

\label{lst:count_directed_graph_connected_components}

The complexity of this algorithm is 
$O(\left|V\right|+\left|E\right|)$

.

This demonstration code shows that two solitary edges are correctly counted
 as being two components:

\lstinputlisting[
  caption = ,
  label = lst:
]{count_directed_graph_connected_components_demo.impl}

Demo of the \verb;count_directed_graph_connected_components; function
\label{lst:count_directed_graph_connected_components_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$$\triangle$ Count the number of connected components in an undirected graph}
\label{subsec:count_undirected_graph_connected_components}

An undirected graph may consist out of two components, that are connect
 within each, but unconnected between them.
 Take for example, a graph of two isolated edges, with four vertices.
 

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
tikz 

\backslash
draw[thick] 

  (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 

    -- (5,2) node[draw=black,fill=white,shape=circle,text=white] {} 

(6,0) node[draw=black,fill=white,shape=circle,text=white] {} 

    -- (10,2) node[draw=black,fill=white,shape=circle,text=white] {} 

;

Example of an undirected graph with two components
\label{fig:count_undirected_graph_connected_components}

This algorithm counts the number of connected components:

\lstinputlisting[
  caption = ,
  label = lst:
]{count_undirected_graph_connected_components.impl}

Count the number of connected components
\index{Count connected components}

\label{lst:count_undirected_graph_connected_components}

The complexity of this algorithm is 
$O(\left|V\right|+\left|E\right|)$

.

This demonstration code shows that two solitary edges are correctly counted
 as being two components:

\lstinputlisting[
  caption = ,
  label = lst:
]{count_undirected_graph_connected_components_demo.impl}

Demo of the \verb;count_undirected_graph_connected_components; function
\label{lst:count_undirected_graph_connected_components_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{$\triangle$$\triangle$ Count the number of levels in an undirected graph}
\label{subsec:count_undirected_graph_levels}

Graphs can have a hierarchical structure.
 From a starting vertex, the number of levels can be counted.
 A graph of one vertex has zero levels.
 A graph with one edge has one level.
 A linear graph of three vertices and two edges has one or two levels, depending
 on the starting vertex.

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
tikz 

\backslash
draw[thick] 

  (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 

    -- (5,2) node[draw=black,fill=white,shape=circle,text=white] {} 

(6,0) node[draw=black,fill=white,shape=circle,text=white] {} 

    -- (10,2) node[draw=black,fill=white,shape=circle,text=white] {} 

;

Example of an undirected graph with two components
\label{fig:count_undirected_graph_levels}

This algorithm counts the number of levels in an undirected graph, starting
 at a certain vertex.
 

It does so, by collecting the neighbours of the traversed vertices.
 Each sweep, all neighbours of traversed neighbours are added to a set of
 known vertices.
 As long as vertices can be added, the algorithm continues.
 If no vertices can be added, the number of level equals the number of sweeps.

\lstinputlisting[
  caption = ,
  label = lst:
]{count_undirected_graph_levels.impl}

Count the number of levels in an undirected graph 
\index{Count undirected graph levels}

\label{lst:count_undirected_graph_levels}

This demonstration code shows the number of levels from a certain vertex,
 while adding edges to form a linear graph.
 The vertex, when still without edges, has zero levels.
 After adding one edge, the graph has one level, etc.

\lstinputlisting[
  caption = ,
  label = lst:
]{count_undirected_graph_levels_demo.impl}

Demo of the \verb;count_undirected_graph_levels; function
\label{lst:count_undirected_graph_levels_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Saving a graph to a .dot file}
\label{subsec:save_graph_to_dot}

\index{Save graph as .dot}

\index{Create .dot from graph}

 

Graph are easily saved to a file, thanks to Graphviz.
 Graphviz
\index{Graphviz}

 (short for Graph Visualization Software) is a package of open-source tools
 for drawing graphs.
 It uses the DOT language for describing graphs, and these are commonly
 stored in (plain-text) .dot files (I show .dot file of every non-empty graph
 created, e.g.
 chapters 
\ref{subsec:create_markov_chain.dot}

 and 
\ref{subsec:create_k2.dot}

)

\lstinputlisting[
  caption = ,
  label = lst:
]{save_graph_to_dot.impl}

Saving a graph to a .dot file
\index{Save graph to dot}

\label{lst:save_graph_to_dot}

All the code does is create an std::ofstream
\index{std::ofstream}

 (an output-to-file stream) and use boost::write_graphviz
\index{boost::write_graphviz}

 to write the DOT description of our graph to that stream.
 Instead of \verb;std::ofstream;, one could use std::cout
\index{std::cout}

 (a related output stream) to display the DOT language on screen directly.

Listing 
\ref{lst:save_graph_to_dot_demo}

 shows how to use the \verb;save_graph_to_dot; function:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_graph_to_dot_demo.impl}

Demonstration of the \verb;save_graph_to_dot; function
\label{lst:save_graph_to_dot_demo}

When using the \verb;save_graph_to_dot; function (algorithm 
\ref{lst:save_graph_to_dot}

), only the structure of the graph is saved: all other properties like names
 are not stored.
 Listing 
\ref{lst:save_named_vertices_graph_to_dot}

 shows how to do so.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading a directed graph from a .dot}
\label{subsec:load_directed_graph_from_dot}

\index{Load directed graph from .dot}

\index{Create directed graph from .dot}

 

When loading a graph from file, one needs to specify a type of graph.
 In this example, an directed graph is loaded, as shown in algorithm 
\ref{lst:load_directed_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_graph_from_dot.impl}

Loading a directed graph from a .dot file
\index{Load directed graph from dot}

\label{lst:load_directed_graph_from_dot}

In this algorithm, first it is checked if the file to load exists, using
 the \verb;is_regular_file; function (algorithm 
\ref{lst:is_regular_file}

), after which an std::ifstream
\index{std::ifstream}

 is opened.
 Then an empty directed graph is created, which saves us writing down the
 template arguments explicitly.
 Then, a boost::dynamic_properties
\index{boost::dynamic_properties}

 is created with the \verb;boost::ignore_other_properties'
\index{boost::ignore_other_properties}

 in its constructor (using a default constructor here results in the run-time
 error \verb;property not found: node_id', see chapter 
\ref{subsec:property_not_found_node_id}

).
 From this and the empty graph, \verb;boost::read_graphviz'
\index{boost::read_graphviz}

 is called to build up the graph.

Listing 
\ref{lst:load_directed_graph_from_dot_demo}

 shows how to use the \verb;load_directed_graph_from_dot' function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_graph_from_dot_demo.impl}

Demonstration of the \verb;load_directed_graph_from_dot' function
\label{lst:load_directed_graph_from_dot_demo}

This demonstration shows how the Markov chain is created using the \verb;create_marko
v_chain_graph' function (algorithm 
\ref{lst:create_markov_chain_graph}

), saved and then loaded.
 The loaded graph is then checked to be a two-state Markov chain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading an undirected graph from a .dot file}
\label{subsec:load_undirected_graph_from_dot}

\index{Load undirected graph from .dot}

\index{Create undirected graph from .dot}

 

Loading an undirected graph from a .dot file is very similar to loading a
 directed graph from a .dot file, as shown in chapter 
\ref{subsec:load_directed_graph_from_dot}

.
 Listing 
\ref{lst:load_undirected_graph_from_dot}

 show how to do so:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_graph_from_dot.impl}

Loading an undirected graph from a .dot file
\index{Load undirected graph from_dot}

\label{lst:load_undirected_graph_from_dot}

The only difference with loading a directed graph, is that the initial empty
 graph is undirected instead.
 Chapter 
\ref{subsec:load_directed_graph_from_dot}

 describes the rationale of this function.
 

Listing 
\ref{lst:load_undirected_graph_from_dot_demo}

 shows how to use the \verb;load_undirected_graph_from_dot' function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_graph_from_dot_demo.impl}

Demonstration of the \verb;load_undirected_graph_from_dot' function
\label{lst:load_undirected_graph_from_dot_demo}

This demonstration shows how the 
$K_{2}$

 graph is created using the \verb;create_k2_graph' function (algorithm 
\ref{lst:create_k2_graph}

), saved and then loaded.
 The loaded graph is checked to be a 
$K_{2}$

 graph.

\section{...}
Building graphs with bundled vertices
\label{sec:Building-graphs-with-bundled-vertices}

Up until now, the graphs created have had edges and vertices without any
 properties.
 In this chapter, graphs will be created, in which the vertices can have
 a bundled \verb;my_bundled_vertex' type
\footnote{I do not intend to be original in naming my data types

.
 The following graphs will be created:

\begin{itemize}
An empty directed graph that allows for bundled vertices: see chapter 
\ref{lst:create_empty_directed_bundled_vertices_graph}

\begin{itemize}
An empty undirected graph that allows for bundled vertices: see chapter
 
\ref{subsec:create_empty_directed_bundled_vertices_graph}

\begin{itemize}
A two-state Markov chain with bundled vertices: see chapter 
\ref{subsec:create_bundled_vertices_markov_chain}

\begin{itemize}
$K_{2}$

with bundled vertices: see chapter 
\ref{subsec:create_bundled_vertices_k2_graph}

In the process, some basic (sometimes bordering trivial) functions are shown:

\begin{itemize}
Create the vertex class, called \verb;my_bundled_vertex': see chapter 
\ref{subsec:my_bundled_vertex}

\begin{itemize}
Adding a \verb;my_bundled_vertex': see chapter 
\ref{subsec:add_bundled_vertex}

\begin{itemize}
Getting the vertices \verb;my_bundled_vertex'-es: see chapter 
\ref{subsec:get_bundled_vertex_my_vertexes}

These functions are mostly there for completion and showing which data types
 are used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating the bundled vertex class}
\label{subsec:my_bundled_vertex}

Before creating an empty graph with bundled vertices, that bundled vertex
 class must be created.
 In this tutorial, it is called \verb;my_bundled_vertex'.
 \verb;my_bundled_vertex' is a class that is nonsensical, but it can be replaced
 by any other class type.

Here I will show the header file of \verb;my_bundled_vertex', as the implementation
 of it is not important:

\lstinputlisting[
  caption = ,
  label = lst:
]{my_bundled_vertex.impl}

Declaration of my_bundled_vertex
\index{my_bundled_vertex}

\index{my_bundled_vertex.h}

\index{my_vertex declaration}

\index{Declaration, my_bundled_vertex}

\label{lst:my_bundled_vertex_h}

\verb;my_bundled_vertex' is a class that has multiple properties: 

\begin{itemize}
It has four public member variables: the double \verb;m_x' (\verb;m_
\index{m_}

' stands for member
\index{member}

), the double \verb;m_y', the std::string m_name and the std::string m_description.
 These variables must be public

\begin{itemize}
It has a default constructor

\begin{itemize}
It is copyable

\begin{itemize}
It is comparable for equality (it has operator==), which is needed for searching

\verb;my_bundled_vertex' does not have to have the stream operators defined for
 file I/O, as this goes via the public member variables.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create the empty directed graph with bundled vertices}
\label{subsec:create_empty_directed_bundled_vertices_graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_bundled_vertices_graph.impl}

Creating an empty directed graph with bundled vertices
\index{Create empty directed bundled vertices graph}

\label{lst:create_empty_directed_bundled_vertices_graph}

This graph:

\begin{itemize}
has its out edges stored in a std::vector (due to the first boost::vecS
\index{boost::vecS}

)

\begin{itemize}
has its vertices stored in a std::vector (due to the second boost::vecS
\index{boost::vecS}

)

\begin{itemize}
is directed (due to the boost::directedS
\index{boost::directedS}

)

\begin{itemize}
The vertices have one property: they have a bundled type, that is of data
 type \verb;my_bundled_vertex'

\begin{itemize}
The edges and graph have no properties

\begin{itemize}
Edges are stored in a std::list

The \verb;boost::adjacency_list; has a new, fourth template argument \verb;my_bundled_vertex
\index{my_bundled_vertex}

'.
 This can be read as: 
\begin_inset Quotes eld

vertices have the bundled property \verb;my_bundled_vertex'
\begin_inset Quotes erd

.
 Or simply: 
\begin_inset Quotes eld

vertices have a bundled type called my_bundled_vertex
\begin_inset Quotes erd

.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create the empty undirected graph with bundled vertices}
\label{subsec:create_empty_undirected_bundled_vertices_graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_bundled_vertices_graph.impl}

Creating an empty undirected graph with bundled vertices
\index{Create empty undirected bundled vertices graph}

\label{lst:create_empty_undirected_bundled_vertices_graph}

This code is very similar to the code described in chapter 
\ref{subsec:create_empty_directed_bundled_vertices_graph}

, except that the directness (the third template argument) is undirected
 (due to the boost::undirectedS
\index{boost::undirectedS}

).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Add a bundled vertex}
\label{subsec:add_bundled_vertex}

Adding a bundled vertex is very similar to adding a named vertex (chapter
 
\ref{subsec:add_named_vertex}

).

\lstinputlisting[
  caption = ,
  label = lst:
]{add_bundled_vertex.impl}

Add a bundled vertex
\index{Add bundled vertex}

\label{lst:add_bundled_vertex}

When having added a new (abstract) vertex to the graph, the vertex descriptor
 is used to set the \verb;my_bundled_vertex' in the graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting the bundled vertices' my_vertexes}

\footnote{the name \verb;my_vertexes' is chosen to indicate this function returns a container
 of my_vertex

\label{subsec:get_bundled_vertex_my_vertexes}

When the vertices of a graph have any bundled \verb;my_bundled_vertex', one can
 extract these as such:

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_vertexes.impl}

Get the bundled vertices' my_vertexes
\index{Get bundled vertex my_vertexes}

\label{lst:get_my_bundled_vertexes}

The \verb;my_bundled_vertex' bundled in each vertex is obtained from a vertex
 descriptor and then put into a std::vector.

The order of the \verb;my_bundled_vertex' objects may be different after saving
 and loading.

When trying to get the vertices' my_bundled_vertex from a graph without
 these, you will get the error \verb;formed reference to void' (see chapter 
\ref{subsec:formed_reference_to_void}

).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating a two-state Markov chain with bundled vertices}
\label{subsec:create_bundled_vertices_markov_chain}

\subsection{Graph}

Figure 
\ref{fig:bundled_vertices_markov_chain}

 shows the graph that will be reproduced:

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick
]   

  
\backslash
tikzstyle{every state}=[]

  
\backslash
node[state] (A) 

    {Sunny, Yellow, 1.0, 2.0};   

  
\backslash
node[state] (B) [right of=A] 

    {Not rainy, Not grey, 3.0, 4.0}

  ;   

  
\backslash
path (A) edge [loop  left] node {} (A)

        (A) edge [bend  left] node {} (B)

        (B) edge [bend  left] node {} (A)

        (B) edge [loop right] node {} (B); 

\backslash
end{tikzpicture}

A two-state Markov chain where the vertices have bundled properties and
 the edges have no properties.
 The vertices' properties are nonsensical
\label{fig:bundled_vertices_markov_chain}

\subsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with bundled vertices:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_vertices_markov_chain.impl}

Creating the two-state Markov chain as depicted in figure 
\ref{fig:bundled_vertices_markov_chain}

\index{Create bundled vertices Markov chain}

\label{lst:create_bundled_vertices_markov_chain}

\subsection{Creating such a graph

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_vertices_markov_chain_demo.impl}

Demo of the \verb;create_bundled_vertices_markov_chain' function (algorithm 
\ref{lst:create_bundled_vertices_markov_chain}

)
\label{lst:create_bundled_and_vertices_markov_chain_demo}

\subsection{The .dot file produced}


\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_vertices_markov_chain.dot}

.dot file created from the \verb;create_bundled_vertices_markov_chain' function
 (algorithm 
\ref{lst:create_bundled_vertices_markov_chain}

), converted from graph to .dot file using algorithm 
\ref{lst:save_bundled_vertices_graph_to_dot}

\label{lst:create_bundled_vertices_markov_chain.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_bundled_vertices_markov_chain.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_bundled_vertices_markov_chain' function
 (algorithm 
\ref{lst:create_bundled_vertices_markov_chain}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_bundled_vertices_markov_chain.svg}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating $K_{2}$ with bundled vertices}
\label{subsec:create_bundled_vertices_k2_graph}

\subsection{Graph}

We reproduce the 
$K_{2}$

 with named vertices of chapter 
\ref{subsec:create_named_vertices_k2_graph}

 , but with our bundled vertices instead, as show in figure 
\ref{fig:bundled_vertices_k2_graph}

:

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]
   

\backslash
tikzstyle{every state}=[]

\backslash
node[state] (A)              {Me,Myself,1.0,2.0};   

\backslash
node[state] (B) [right of=A] {My computer,Not me,3.0,4.0};   

\backslash
path (A) edge [] node {} (B); 

\backslash
end{tikzpicture}

$K_{2}$

: a fully connected graph with two bundled vertices
\label{fig:bundled_vertices_k2_graph}

\subsection{Function to create such a graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_vertices_k2_graph.impl}

Creating 
$K_{2}$

 as depicted in figure 
\ref{fig:named_vertices_k2_graph}

\index{Create bundled vertices K2 graph}
\label{lst:create_bundled_vertices_k2_graph}

Most of the code is a slight modification of the \verb;create_named_vertices_k2_graph
' function (algorithm 
\ref{lst:create_named_vertices_k2_graph}

).
 In the end, (references to) the my_bundled_vertices are obtained and set
 with two bundled my_bundled_vertex objects.

\subsection{Creating such a graph

Demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_vertices_k2_graph_demo.impl}

Demo of the \verb;create_bundled_vertices_k2_graph' function (algorithm 
\ref{lst:create_bundled_vertices_k2_graph}

)
\label{lst:create_bundled_vertices_k2_graph_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_vertices_k2_graph.dot}

.dot file created from the \verb;create_bundled_vertices_k2_graph' function (algorithm
 
\ref{lst:create_bundled_vertices_k2_graph}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_bundled_vertices_k2_graph.dot-1}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_bundled_vertices_k2_graph.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_bundled_vertices_k2_graph' function (algorithm
 
\ref{lst:create_bundled_vertices_k2_graph}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_bundled_vertices_k2_graph.svg}

\section{...}
Working on graphs with bundled vertices
\label{sec:Working-on-graphs-with-bundled-vertices}

When using graphs with bundled vertices, their state gives a way to find
 a vertex and working with it.
 This chapter shows some basic operations on graphs with bundled vertices.

\begin{itemize}
Check if there exists a vertex with a certain \verb;my_bundled_vertex': chapter
 
\ref{subsec:has_bundled_vertex_with_my_vertex}

\begin{itemize}
Find a vertex with a certain \verb;my_bundled_vertex': chapter 
\ref{subsec:find_bundled_vertex_with_my_vertex}

\begin{itemize}
Get a vertex its \verb;my_bundled_vertex' from its vertex descriptor: chapter
 
\ref{subsec:get_bundled_vertex_my_vertex}

\begin{itemize}
Set a vertex its \verb;my_bundled_vertex' using its vertex descriptor: chapter
 
\ref{subsec:set_bundled_vertex_my_vertex}

\begin{itemize}
Setting all vertices their \verb;my_bundled_vertex'-es: chapter 
\ref{subsec:set_bundled_vertex_my_vertexes}

\begin{itemize}
Storing an directed/undirected graph with bundled vertices as a .dot file:
 chapter 
\ref{subsec:save_bundled_vertices_graph_to_dot}

\begin{itemize}
Loading a directed graph with bundled vertices from a .dot file: chapter
 
\ref{subsec:load_directed_bundled_vertices_graph_from_dot}

\begin{itemize}
Loading an undirected directed graph with bundled vertices from a .dot file:
 chapter 
\ref{subsec:load_undirected_bundled_vertices_graph_from_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Has a bundled vertex with a my_bundled_vertex}
\label{subsec:has_bundled_vertex_with_my_vertex}

Before modifying our vertices, let's first determine if we can find a vertex
 by its bundled type (\verb;my_bundled_vertex') in a graph.
 After obtain the vertex iterators, we can dereference each these to obtain
 the vertex descriptors and then compare each vertex its \verb;my_bundled_vertex'
 with the one desired.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_vertex_with_my_vertex.impl}

Find if there is vertex with a certain my_bundled_vertex
\index{Has bundled vertex with my_vertex}

\label{lst:has_bundled_vertex_with_my_vertex}

This function can be demonstrated as in algorithm 
\ref{lst:has_bundled_vertex_with_my_vertex_demo}

, where a certain my_bundled_vertex cannot be found in an empty graph.
 After adding the desired my_bundled_vertex, it is found.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_vertex_with_my_vertex_demo.impl}

Demonstration of the \verb;has_bundled_vertex_with_my_vertex' function
\label{lst:has_bundled_vertex_with_my_vertex_demo}

Note that this function only finds if there is at least one bundled vertex
 with that my_bundled_vertex: it does not tell how many bundled vertices
 with that my_bundled_vertex exist in the graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find a bundled vertex with a certain my_bundled_vertex}
\label{subsec:find_bundled_vertex_with_my_vertex}

Where STL functions work with iterators, here we obtain a vertex descriptor
 (see chapter 
\ref{subsec:Vertex-descriptors}

) to obtain a handle to the desired vertex.
 Listing 
\ref{lst:find_first_bundled_vertex_with_my_vertex}

 shows how to obtain a vertex descriptor to the first vertex found with
 a specific \verb;my_bundled_vertex' value.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_vertex_with_my_vertex.impl}

Find the first vertex with a certain my_bundled_vertex
\index{Find first bundled vertex with my_vertex}

\label{lst:find_first_bundled_vertex_with_my_vertex}

With the vertex descriptor obtained, one can read and modify the vertex
 and the edges surrounding it.
 Listing 
\ref{lst:find_first_bundled_vertex_with_my_vertex_demo}

 shows some examples of how to do so.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_vertex_with_my_vertex_demo.impl}

Demonstration of the \verb;find_first_bundled_vertex_with_my_vertex' function
\label{lst:find_first_bundled_vertex_with_my_vertex_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Get a bundled vertex its \verb;my_bundled_vertex;}
\label{subsec:get_bundled_vertex_my_vertex}

To obtain the \verb;my_bundled_vertex' from a vertex descriptor is simple:

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_vertex.impl}

Get a bundled vertex its my_vertex from its vertex descriptor
\index{Get bundled vertex my_bundled_vertex

\label{lst:get_bundled_vertex_my_vertex}

One can just use the graph as a property map and let it be looked-up.

To use \verb;get_bundled_vertex_my_vertex', one first needs to obtain a vertex
 descriptor.
 Listing 
\ref{lst:get_bundled_vertex_my_vertex_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_vertex_demo.impl}

Demonstration if the \verb;get_bundled_vertex_my_vertex' function
\label{lst:get_bundled_vertex_my_vertex_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set a bundled vertex its my_vertex}
\label{subsec:set_bundled_vertex_my_vertex}

If you know how to get the \verb;my_bundled_vertex' from a vertex descriptor,
 setting it is just as easy, as shown in algorithm 
\ref{lst:set_bundled_vertex_my_vertex}

.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_vertex.impl}

Set a bundled vertex its my_vertex from its vertex descriptor
\index{Set vertex my_vertex

\label{lst:set_bundled_vertex_my_vertex}

To use \verb;set_bundled_vertex_my_vertex', one first needs to obtain a vertex
 descriptor.
 Listing 
\ref{lst:set_bundled_vertex_my_vertex_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_vertex_demo.impl}

Demonstration if the \verb;set_bundled_vertex_my_vertex' function
\label{lst:set_bundled_vertex_my_vertex_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Setting all bundled vertices' my_vertex objects}
\label{subsec:set_bundled_vertex_my_vertexes}

When the vertices of a graph are \verb;my_bundled_vertex' objects, one can set
 these as such:

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_vertexes.impl}

Setting the bundled vertices' \verb;my_bundled_vertex'-es
\index{Set bundled vertex my_bundled_vertexes

\label{lst:set_bundled_vertex_my_vertexes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Storing a graph with bundled vertices as a .dot}
\label{subsec:save_bundled_vertices_graph_to_dot}

If you used the \verb;create_bundled_vertices_k2_graph' function (algorithm 
\ref{lst:create_bundled_vertices_k2_graph}

) to produce a 
$K_{2}$

 graph with vertices associated with \verb;my_bundled_vertex' objects, you can
 store these with algorithm 
\ref{lst:save_bundled_vertices_graph_to_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_bundled_vertices_graph_to_dot.impl}

Storing a graph with bundled vertices as a .dot file
\index{Save bundled vertices graph to dot

\label{lst:save_bundled_vertices_graph_to_dot}

This code looks small, because we call the \verb;make_bundled_vertices_writer'
 function, which is shown in algorithm 
\ref{lst:make_bundled_vertices_writer}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{make_bundled_vertices_writer.impl}

The \verb;make_bundled_vertices_writer' function
\index{make_bundled_vertices_writer

\label{lst:make_bundled_vertices_writer}

Also this function is forwarding the real work to the \verb;bundled_vertices_writer',
 shown in algorithm 
\ref{lst:bundled_vertices_writer}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{bundled_vertices_writer.impl}

The \verb;bundled_vertices_writer' function
\index{bundled_vertices_writer

\label{lst:bundled_vertices_writer}

Here, some interesting things are happening: the writer needs the bundled
 property maps to work with and thus copies the whole graph to its internals.
 I have chosen to map the \verb;my_bundled_vertex' member variables to Graphviz
 attributes (see chapter 
\ref{subsec:Graphviz-attributes}

 for most Graphviz attributes) as shown in table 
\ref{tab:Mapping-of-my_bundled_vertex-to-Graphviz-attributes}

:

\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_inset Tabular
<lyxtabular version=}3} rows=}5} columns=}4}>
<features tabularvalignment=}middle}>
<column alignment=}center} valignment=}top}>
<column alignment=}center} valignment=}top}>
<column alignment=}center} valignment=}top}>
<column alignment=}center} valignment=}top}>
<row>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

my_bundled_vertex variable

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

C++ data type

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

Graphviz data type

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

Graphviz attribute

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_name

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

std::string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

label

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_description

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

std::string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

comment

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_x

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

width

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_y

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

height

</cell>
</row>
</lyxtabular>

Mapping of my_bundled_vertex member variable and Graphviz attributes
\label{tab:Mapping-of-my_bundled_vertex-to-Graphviz-attributes}

Important in this mapping is that the C++ and the Graphviz data types match.
 I also chose attributes that matched as closely as possible.

The writer also encodes the std::string of the name and description to a
 Graphviz-friendly format.
 When loading the .dot file again, this will have to be undone again.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading a directed graph with bundled vertices from a .dot}
\label{subsec:load_directed_bundled_vertices_graph_from_dot}

When loading a graph from file, one needs to specify a type of graph.
 In this example, an directed graph with bundled vertices is loaded, as
 shown in algorithm 
\ref{lst:load_directed_bundled_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_vertices_graph_from_dot.impl}

Loading a directed graph with bundled vertices from a .dot file
\index{Load directed bundled vertices graph from dot

\label{lst:load_directed_bundled_vertices_graph_from_dot}

In this algorithm, first it is checked if the file to load exists.
 Then an empty directed graph is created, to save typing the typename explicitly.

Then a boost::dynamic_properties
\index{boost::dynamic_properties

 is created with its default constructor, after which we set it to follow
 the same mapping as in the previous chapter.
 From this and the empty graph, \verb;boost::read_graphviz'
\index{boost::read_graphviz

 is called to build up the graph.

At the moment the graph is created, all \verb;my_bundled_vertex' their names
 and description are in a Graphviz-friendly format.
 By obtaining all vertex iterators and vertex descriptors, the encoding
 is made undone.

Listing 
\ref{lst:load_directed_bundled_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_directed_bundled_vertices_graph_from_dot' function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_directed_bundled_vertices_graph_from_dot' function
\label{lst:load_directed_bundled_vertices_graph_from_dot_demo}

This demonstration shows how the Markov chain is created using the \verb;create_bundl
ed_vertices_markov_chain' function (algorithm 
\ref{lst:create_bundled_vertices_markov_chain}

), saved and then loaded.
 The loaded graph is checked to be the same as the original.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading an undirected graph with bundled vertices from a .dot}
\label{subsec:load_undirected_bundled_vertices_graph_from_dot}

When loading a graph from file, one needs to specify a type of graph.
 In this example, an undirected graph with bundled vertices is loaded, as
 shown in algorithm 
\ref{lst:load_undirected_bundled_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_vertices_graph_from_dot.impl}

Loading an undirected graph with bundled vertices from a .dot file
\index{Load undirected bundled vertices graph from dot

\label{lst:load_undirected_bundled_vertices_graph_from_dot}

The only difference with loading a directed graph, is that the initial empty
 graph is undirected instead.
 Chapter 
\ref{subsec:load_directed_bundled_vertices_graph_from_dot}

 describes the rationale of this function.
 

Listing 
\ref{lst:load_undirected_bundled_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_undirected_bundled_vertices_graph_from_dot'
 function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_undirected_bundled_vertices_graph_from_dot' function
\label{lst:load_undirected_bundled_vertices_graph_from_dot_demo}

This demonstration shows how 
$K_{2}$

 with bundled vertices is created using the \verb;create_bundled_vertices_k2_graph'
 function (algorithm 
\ref{lst:create_bundled_vertices_k2_graph}

), saved and then loaded.
 The loaded graph is checked to be the same as the original.

\section{...}
Building graphs with bundled edges and vertices

Up until now, the graphs created have had only bundled vertices.
 In this chapter, graphs will be created, in which both the edges and vertices
 have a bundled \verb;my_bundled_edge' and \verb;my_bundled_edge' type
\footnote{I do not intend to be original in naming my data types

.

\begin{itemize}
An empty directed graph that allows for bundled edges and vertices: see
 chapter 
\ref{subsec:create_empty_directed_bundled_edges_and_vertices_graph}

\begin{itemize}
An empty undirected graph that allows for bundled edges and vertices: see
 chapter 
\ref{subsec:create_empty_undirected_bundled_edges_and_vertices_graph}

\begin{itemize}
A two-state Markov chain with bundled edges and vertices: see chapter 
\ref{subsec:create_bundled_edges_and_vertices_markov_chain}

\begin{itemize}
$K_{3}$

with bundled edges and vertices: see chapter 
\ref{subsec:create_bundled_edges_and_vertices_k3}

In the process, some basic (sometimes bordering trivial) functions are shown:

\begin{itemize}
Creating the \verb;my_bundled_edge' class: see chapter 
\ref{subsec:my_bundled_edge}

\begin{itemize}
Adding a bundled \verb;my_bundled_edge': see chapter 
\ref{subsec:add_bundled_edge}

These functions are mostly there for completion and showing which data types
 are used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating the bundled edge class}
\label{subsec:my_bundled_edge}

In this example, I create a \verb;my_bundled_edge' class.
 Here I will show the header file of it, as the implementation of it is
 not important yet.

\lstinputlisting[
  caption = ,
  label = lst:
]{my_bundled_edge.impl}

Declaration of my_bundled_edge
\index{my_bundled_edge

\index{my_bundled_edge.h

\index{my_bundled_edge declaration

\index{Declaration, my_bundled_edge

\label{lst:my_bundled_edge_h}

my_bundled_edge is a class that has multiple properties: two doubles \verb;m_width'
 (\verb;m_
\index{m_

' stands for member
\index{member

) and \verb;m_height', and two std::strings m_name and m_description.\verb;my_bundled_edge'
 is copyable, but cannot trivially be converted to a \verb;std::string.' \verb;my_bundled_e
dge' is comparable for equality (that is, operator== is defined).

\verb;my_bundled_edge' does not have to have the stream operators defined for
 file I/O, as this goes via the public member variables.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty directed graph with bundled edges and vertices}
\label{subsec:create_empty_directed_bundled_edges_and_vertices_graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_bundled_edges_and_vertices_graph.impl}

Creating an empty directed graph with bundled edges and vertices
\index{Create empty directed bundled edges and vertices graph

\label{lst:create_empty_directed_bundled_edges_and_vertices_graph}

This code is very similar to the code described in chapter 
\ref{subsec:create_empty_directed_custom_vertices_graph}

, except that there is a new, fifth template argument:

\begin_inset listings
inline false
status open

boost::property<boost::edge_bundled_type_t, my_edge>

\index{boost::property

\index{boost::edge_bundled_type_t

\index{my_edge

This can be read as: 
\begin_inset Quotes eld

edges have the property \verb;boost::edge_bundled_type_t', which is of data type
 \verb;my_bundled_edge'
\begin_inset Quotes erd

.
 Or simply: 
\begin_inset Quotes eld

edges have a bundled type called my_bundled_edge
\begin_inset Quotes erd

.

Demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_bundled_edges_and_vertices_graph_demo.impl}

Demonstration of the \verb;create_empty_directed_bundled_edges_and_vertices_graph'
 function
\label{lst:create_empty_directed_bundled_edges_and_vertices_graph_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty undirected graph with bundled edges and vertices}
\label{subsec:create_empty_undirected_bundled_edges_and_vertices_graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_bundled_edges_and_vertices_graph.impl}

Creating an empty undirected graph with bundled edges and vertices
\index{Create empty undirected bundled edges and vertices graph

\label{lst:create_empty_undirected_bundled_edges_and_vertices_graph}

This code is very similar to the code described in chapter 
\ref{subsec:create_empty_directed_bundled_edges_and_vertices_graph}

, except that the directness (the third template argument) is undirected
 (due to the boost::undirectedS
\index{boost::undirectedS

).

Demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_bundled_edges_and_vertices_graph_demo.impl}

Demonstration of the \verb;create_empty_undirected_bundled_edges_and_vertices_graph'
 function
\label{lst:create_empty_undirected_bundled_edges_and_vertices_graph_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Add a bundled edge}
\label{subsec:add_bundled_edge}

Adding a bundled edge is very similar to adding a named edge (chapter 
\ref{subsec:add_named_edge}

).

\lstinputlisting[
  caption = ,
  label = lst:
]{add_bundled_edge.impl}

Add a bundled edge
\index{Add bundled edge

\label{lst:add_bundled_edge}

When having added a new (abstract) edge to the graph, the edge descriptor
 is used to set the my_edge in the graph.

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{add_bundled_edge_demo.impl}

Demo of \verb;add_bundled_edge'
\label{lst:add_bundled_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting the bundled edges my_edges}
\label{subsec:get_bundled_edge_my_edges}

When the edges of a graph are \verb;my_bundled_edge' objects, one can extract
 these all as such:

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_edges.impl}

Get the edges' my_bundled_edges
\index{Get edge my_bundled_edges

\label{lst:get_bundled_edge_my_edges}

The \verb;my_bundled_edge' object associated with the edges are obtained from
 the graph its property_map and then put into a std::vector.

Note: the order of the my_bundled_edge objects may be different after saving
 and loading.

When trying to get the edges' my_bundled_edge objects from a graph without
 bundled edges objects associated, you will get the error \verb;formed reference
 to void' (see chapter 
\ref{subsec:formed_reference_to_void}

).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating a Markov-chain with bundled edges and vertices}
\label{subsec:create_bundled_edges_and_vertices_markov_chain}

\subsection{Graph}

Figure 
\ref{fig:bundled_edges_and_vertices_markov_chain}

 shows the graph that will be reproduced:

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=9cm, semithick
]   

  
\backslash
tikzstyle{every state}=[]

  
\backslash
node[state] (A) 

    {Stable,Right, 1.0, 2.0};   

  
\backslash
node[state] (B) [right of=A] 

    {Not unstable,Not left, 3.0, 4.0}

  ;   

  
\backslash
path (A) edge [loop above] node {Red,Heat,1,2} (A)

        (A) edge [bend  left] node {Orange,Lose heat,3,4} (B)

        (B) edge [bend  left] node {Yellow cold,Heat,4,5} (A)

        (B) edge [loop above] node {Green cols,Stay cool,6,7} (B); 

\backslash
end{tikzpicture}

A two-state Markov chain where the edges and vertices have bundled properties.
 The edges' and vertices' properties are nonsensical
\label{fig:bundled_edges_and_vertices_markov_chain}

\subsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with bundled edges and
 vertices:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_markov_chain.impl}

Creating the two-state Markov chain as depicted in figure 
\ref{fig:bundled_edges_and_vertices_markov_chain}

\index{Create bundled edges and vertices Markov chain

\label{lst:create_bundled_edges_and_vertices_markov_chain}

\subsection{Creating such a graph

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_markov_chain_demo.impl}

Demo of the \verb;create_bundled_edges_and_vertices_markov_chain' function (algorithm
 
\ref{lst:create_bundled_edges_and_vertices_markov_chain}

)
\label{lst:create_bundled_edges_and_vertices_markov_chain_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_markov_chain.dot}

.dot file created from the \verb;create_bundled_edges_and_vertices_markov_chain'
 function (algorithm 
\ref{lst:create_bundled_edges_and_vertices_markov_chain}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_bundled_edges_and_vertices_markov_chain.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_bundled_edges_and_vertices_markov_chain.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_bundled_edges_and_vertices_markov_chain'
 function (algorithm 
\ref{lst:create_custom_vertices_markov_chain}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_bundled_edges_and_vertices_markov_chain.svg}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating $K_{3}$  with bundled edges and vertices}
\label{subsec:create_bundled_edges_and_vertices_k3}

Instead of using edges with a name, or other properties, here we use a bundled
 edge class called \verb;my_bundled_edge'.

\subsection{Graph}

We reproduce the 
$K_{3}$

 with named edges and vertices of chapter 
\ref{subsec:create_named_edges_and_vertices_k3}

 , but with our bundled edges and vertices instead:

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\backslash
tikz 

\backslash
draw[] 

  (2,4) node[draw=black,fill=white,shape=circle,text=black] {Red,Not green,1,2}
 

   -- (5,2) node[anchor=west] {Oxygen,Air,1,2} 

   -- (8,0) node[draw=black,fill=white,shape=circle,text=black] {Light red,Not
 dark,3,4} 

   -- (4,0) node[anchor=north] {Helium,From tube,3,4} 

   -- (0,0) node[draw=black,fill=white,shape=circle,text=black] {Orange,Orange,5
,6} 

   -- (1,2) node[anchor=east] {Stable temperature,Here,5,6} 

   -- (2,4)

;

$K_{3}$

: a fully connected graph with three named edges and vertices 
\label{fig:create_bundled_edges_and_vertices_k3}

\subsection{Function to create such a graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_k3_graph.impl}

Creating 
$K_{3}$

 as depicted in figure 
\ref{fig:named_edges_and_vertices_k3}

\index{Create bundled edges and vertices K3 graph

\label{lst:create_bundled_edges_and_vertices_k3_graph}

Most of the code is a slight modification of algorithm 
\ref{lst:create_named_edges_and_vertices_k3_graph}

.
 In the end, the my_edges and my_vertices are obtained as the graph its
 property_map and set with the \verb;my_bundled_edge' and \verb;my_bundled_vertex'
 objects.

\subsection{Creating such a graph

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_k3_graph_demo.impl}

Demo of the \verb;create_bundled_edges_and_vertices_k3_graph' function (algorithm
 
\ref{lst:create_bundled_edges_and_vertices_k3_graph}

)
\label{lst:create_bundled_edges_and_vertices_k3_graph_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_k3_graph.dot}

.dot file created from the \verb;create_bundled_edges_and_vertices_markov_chain'
 function (algorithm 
\ref{lst:create_bundled_edges_and_vertices_k3_graph}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_bundled_edges_and_vertices_k3_graph.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_bundled_edges_and_vertices_k3_graph.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_bundled_edges_and_vertices_k3_graph' function
 (algorithm 
\ref{lst:create_custom_vertices_markov_chain}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_bundled_edges_and_vertices_k3_graph.svg}

\section{...}
Working on graphs with bundled edges and vertices

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Has a my_bundled_edge}
\label{subsec:has_bundled_edge_with_my_edge}

Before modifying our edges, let's first determine if we can find an edge
 by its bundled type (\verb;my_bundled_edge') in a graph.
 After obtaining a my_bundled_edge map, we obtain the edge iterators, dereferenc
e these to obtain the edge descriptors and then compare each edge its my_bundled
_edge with the one desired.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_edge_with_my_edge.impl}

Find if there is a bundled edge with a certain my_bundled_edge
\index{Has bundled edge with my_bundled_edge

\label{lst:has_bundled_edge_with_my_edge}

This function can be demonstrated as in algorithm 
\ref{lst:has_bundled_edge_with_my_edge_demo}

, where a certain \verb;my_bundled_edge' cannot be found in an empty graph.
 After adding the desired my_bundled_edge, it is found.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_edge_with_my_edge_demo.impl}

Demonstration of the \verb;has_bundled_edge_with_my_edge' function
\label{lst:has_bundled_edge_with_my_edge_demo}

Note that this function only finds if there is at least one edge with that
 my_bundled_edge: it does not tell how many edges with that my_bundled_edge
 exist in the graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find a my_bundled_edge}
\label{subsec:find_first_bundled_edge_with_my_edge}

Where STL functions work with iterators, here we obtain an edge descriptor
 (see chapter 
\ref{subsec:Edge-descriptors}

) to obtain a handle to the desired edge.
 Listing 
\ref{lst:find_first_bundled_edge_with_my_edge}

 shows how to obtain an edge descriptor to the first edge found with a specific
 my_bundled_edge value.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_edge_with_my_edge.impl}

Find the first bundled edge with a certain my_bundled_edge
\index{Find first bundled edge with my_bundled_edge

\label{lst:find_first_bundled_edge_with_my_edge}

With the edge descriptor obtained, one can read and modify the edge and
 the vertices surrounding it.
 Listing 
\ref{lst:find_first_bundled_edge_with_my_edge_demo}

 shows some examples of how to do so.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_edge_with_my_edge_demo.impl}

Demonstration of the \verb;find_first_bundled_edge_with_my_edge' function
\label{lst:find_first_bundled_edge_with_my_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Get an edge its my_bundled_edge}
\label{subsec:get_bundled_edge_my_edge}

To obtain the my_bundled_edge from an edge descriptor, one needs to pull
 out the my_bundled_edges map and then look up the my_edge of interest.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_edge.impl}

Get a vertex its my_bundled_vertex from its vertex descriptor
\index{Get my_bundled_edge

\label{lst:get_bundled_edge_my_edge}

To use \verb;get_my_bundled_edge', one first needs to obtain an edge descriptor.
 Listing 
\ref{lst:get_bundled_edge_my_edge_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_edge_demo.impl}

Demonstration if the \verb;get_my_bundled_edge' function
\label{lst:get_bundled_edge_my_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set an edge its my_bundled_edge}
\label{subsec:set_bundled_edge_my_edge}

If you know how to get the my_bundled_edge from an edge descriptor, setting
 it is just as easy, as shown in algorithm 
\ref{lst:set_bundled_edge_my_edge}

.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_edge.impl}

Set a bundled edge its my_bundled_edge from its edge descriptor
\index{Set bundled edge my_bundled_edge

\label{lst:set_bundled_edge_my_edge}

To use \verb;set_bundled_edge_my_edge', one first needs to obtain an edge descriptor.
 Listing 
\ref{lst:set_bundled_edge_my_edge_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_edge_demo.impl}

Demonstration if the \verb;set_bundled_edge_my_edge' function
\label{lst:set_bundled_edge_my_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Storing a graph with bundled edges and vertices as a .dot}
\label{subsec:save_bundled_edges_and_vertices_graph_to_dot}

\index{Save graph with bundled edges and vertices as .dot

\index{Create .dot from graph with bundled edges and vertices

 

If you used the \verb;create_bundled_edges_and_vertices_k3_graph' function (algorithm
 
\ref{lst:create_bundled_edges_and_vertices_k3_graph}

) to produce a 
$K_{3}$

graph with edges and vertices associated with my_bundled_edge and my_bundled_ver
tex objects, you can store these my_bundled_edges and my_bundled_vertex-es
 additionally with algorithm 
\ref{lst:save_bundled_edges_and_vertices_graph_to_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_bundled_edges_and_vertices_graph_to_dot.impl}

Storing a graph with bundled edges and vertices as a .dot file
\index{Save bundled edges and vertices graph to dot

\label{lst:save_bundled_edges_and_vertices_graph_to_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load a directed graph with bundled edges and vertices from a .dot file}
\label{subsec:sub:load_directed_bundled_edges_and_vertices_graph_from_dot}

When loading a graph from file, one needs to specify a type of graph.
 In this example, an directed graph with bundled edges and vertices is loaded,
 as shown in algorithm 
\ref{lst:load_directed_bundled_edges_and_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_edges_and_vertices_graph_from_dot.impl}

Loading a directed graph with bundled edges and vertices from a .dot file
\index{Load directed bundled edges and vertices graph from dot

\label{lst:load_directed_bundled_edges_and_vertices_graph_from_dot}

In this algorithm, first it is checked if the file to load exists.
 Then an empty directed graph is created.
 Next to this, a boost::dynamic_properties
\index{boost::dynamic_properties

 is created with its default constructor, after which we direct the boost::dynam
ic_properties
\index{boost::dynamic_properties

 to find a \verb;node_id' and \verb;label' in the vertex name map, \verb;edge_id' and \verb;label'
 to the edge name map.
 From this and the empty graph, \verb;boost::read_graphviz'
\index{boost::read_graphviz

 is called to build up the graph.

Listing 
\ref{lst:load_directed_bundled_edges_and_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_directed_bundled_edges_and_vertices_graph_from_dot'
 function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_edges_and_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_directed_bundled_edges_and_vertices_graph_from_dot'fu
nction
\label{lst:load_directed_bundled_edges_and_vertices_graph_from_dot_demo}

This demonstration shows how the Markov chain is created using the \verb;create_bundl
ed_edges_and_vertices_markov_chain' function (algorithm 
\ref{lst:create_bundled_edges_and_vertices_markov_chain}

), saved and then loaded.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load an undirected graph with bundled edges and vertices from a .dot file}
\label{subsec:load_undirected_bundled_edges_and_vertices_graph_from_dot}

\index{Load undirected graph with bundled edges and vertices from .dot

\index{Create undirected graph with bundled edges and vertices from .dot

When loading a graph from file, one needs to specify a type of graph.
 In this example, an undirected graph with bundled edges and vertices is
 loaded, as shown in algorithm 
\ref{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_edges_and_vertices_graph_from_dot.impl}

Loading an undirected graph with bundled edges and vertices from a .dot file
\index{Load undirected bundled edges and vertices graph from dot

\label{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot}

The only difference with loading a directed graph, is that the initial empty
 graph is undirected instead.
 Chapter 
\ref{subsec:sub:load_directed_bundled_edges_and_vertices_graph_from_dot}

 describes the rationale of this function.
 

Listing 
\ref{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_undirected_bundled_vertices_graph_from_dot'
 function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_edges_and_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_undirected_bundled_edges_and_vertices_graph_from_dot'
function
\label{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot_demo}

This demonstration shows how 
$K_{2}$

 with bundled vertices is created using the \verb;create_bundled_vertices_k2_graph'
 function (algorithm 
\ref{lst:create_custom_vertices_k2_graph}

), saved and then loaded.
 The loaded graph is checked to be a graph similar to the original.

\section{...}
Building graphs with a graph name
\label{sec:Building-graphs-with-a-graph-name}

Up until now, the graphs created have had no properties themselves.
 Sure, the edges and vertices have had properties, but the graph itself
 has had none.
 Until now.

In this chapter, graphs will be created with a graph name of type std::string

\begin{itemize}
An empty directed graph with a graph name: see chapter 

\begin{itemize}
An empty undirected graph with a graph name: see chapter 

\begin{itemize}
A two-state Markov chain with a graph name: see chapter

\begin{itemize}
$K_{3}$

with a graph name: see chapter 

In the process, some basic (sometimes bordering trivial) functions are shown:

\begin{itemize}
Getting a graph its name: see chapter 

\begin{itemize}
Setting a graph its name: see chapter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty directed graph with a graph name property}
\label{subsec:create_empty_directed_graph_with_graph_name}

Listing 
\ref{lst:create_empty_directed_graph_with_graph_name}

 shows the function to create an empty directed graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_graph_with_graph_name.impl}

Creating an empty directed graph with a graph name
\index{Create empty directed graph with graph name

\label{lst:create_empty_directed_graph_with_graph_name}

This \verb;boost::adjacency_list; is of the following type:

\begin{itemize}
the first \verb;boost::vecS'
\index{boost::vecS

: select (that is what the \verb;S
\index{S

' means) that out edges are stored in a std::vector.
 This is the default way.

\begin{itemize}
the second \verb;boost::vecS'
\index{boost::vecS

: select that the graph vertices are stored in a std::vector.
 This is the default way.

\begin{itemize}
\verb;boost::directedS'
\index{boost::directedS

: select that the graph is directed.
 This is the default selectedness

\begin{itemize}
the first \verb;boost::no_property'
\index{boost::no_property

: the vertices have no properties.
 This is the default (non-)property

\begin{itemize}
the second \verb;boost::no_property'
\index{boost::no_property

: the vertices have no properties.
 This is the default (non-)property

\begin{itemize}
\verb;boost::property<boost::graph_name_t, std::string>'
\index{boost::property

\index{boost::graph_name_t

: the graph itself has a single property: its boost::graph_name
\index{boost::graph_name

 has type std::string

Listing 
\ref{lst:create_empty_directed_graph_with_graph_name_demo}

 demonstrates the \verb;create_empty_directed_graph_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_graph_with_graph_name_demo.impl}

Demonstration of \verb;create_empty_directed_graph_with_graph_name'
\label{lst:create_empty_directed_graph_with_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty undirected graph with a graph name property}
\label{subsec:create_empty_undirected_graph_with_graph_name}

Listing 
\ref{lst:create_empty_undirected_graph_with_graph_name}

 shows the function to create an empty undirected graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_graph_with_graph_name.impl}

Creating an empty undirected graph with a graph name
\index{Create empty undirected graph with graph name

\label{lst:create_empty_undirected_graph_with_graph_name}

This code is very similar to the code described in chapter 
\ref{lst:create_empty_directed_graph_with_graph_name}

, except that the directness (the third template argument) is undirected
 (due to the boost::undirectedS
\index{boost::undirectedS

).

Listing 
\ref{lst:create_empty_undirected_graph_with_graph_name_demo}

 demonstrates the \verb;create_empty_undirected_graph_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_graph_with_graph_name_demo.impl}

Demonstration of \verb;create_empty_undirected_graph_with_graph_name'
\label{lst:create_empty_undirected_graph_with_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Get a graph its name property}
\label{subsec:get_graph_name}

\lstinputlisting[
  caption = ,
  label = lst:
]{get_graph_name.impl}

Get a graph its name
\index{Get graph name

\label{lst:get_graph_name}

Listing 
\ref{lst:get_graph_name_demo}

 demonstrates the \verb;get_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_graph_name_demo.impl}

Demonstration of \verb;get_graph_name'
\label{lst:get_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set a graph its name property}
\label{subsec:set_graph_name}

\lstinputlisting[
  caption = ,
  label = lst:
]{set_graph_name.impl}

Set a graph its name
\index{Set graph name

\label{lst:set_graph_name}

Listing 
\ref{lst:set_graph_name_demo}

 demonstrates the \verb;set_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_graph_name_demo.impl}

Demonstration of \verb;set_graph_name'
\label{lst:set_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create a directed graph with a graph name property}
\label{subsec:create_markov_chain_with_graph_name}

\subsection{Graph}

See figure 
\ref{fig:markov_chain}

.

\subsection{Function to create such a graph}

Listing 
\ref{lst:create_markov_chain_with_graph_name}

 shows the function to create an empty directed graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_markov_chain_with_graph_name.impl}

Creating a two-state Markov chain with a graph name
\index{Create Markov chain with graph name

\label{lst:create_markov_chain_with_graph_name}

\subsection{Creating such a graph

Listing 
\ref{lst:create_markov_chain_with_graph_name_demo}

 demonstrates the \verb;create_markov_chain_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_markov_chain_with_graph_name_demo.impl}

Demonstration of \verb;create_markov_chain_with_graph_name'
\label{lst:create_markov_chain_with_graph_name_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_markov_chain_with_graph_name.dot}

.dot file created from the \verb;create_markov_chain_with_graph_name' function
 (algorithm 
\ref{lst:create_markov_chain_with_graph_name}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_markov_chain_with_graph_name.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_markov_chain_with_graph_name.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_markov_chain_with_graph_name' function
 (algorithm 
\ref{lst:create_markov_chain_with_graph_name}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_markov_chain_with_graph_name.svg}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an undirected graph with a graph name property}
\label{subsec:create_k2_graph_with_graph_name}

\subsection{Graph}

See figure 
\ref{fig:k2_graph}

.

\subsection{Function to create such a graph}

Listing 
\ref{lst:create_k2_graph_with_graph_name}

 shows the function to create K2 graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_k2_graph_with_graph_name.impl}

Creating a K2 graph with a graph name
\index{Create K2 graph with graph name

\label{lst:create_k2_graph_with_graph_name}

\subsection{Creating such a graph

Listing 
\ref{lst:create_k2_graph_with_graph_name_demo}

 demonstrates the \verb;create_k2_graph_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_k2_graph_with_graph_name_demo.impl}

Demonstration of \verb;create_k2_graph_with_graph_name'
\label{lst:create_k2_graph_with_graph_name_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_k2_graph_with_graph_name.dot}

.dot file created from the \verb;create_k2_graph_with_graph_name' function (algorithm
 
\ref{lst:create_k2_graph_with_graph_name}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_k2_graph_with_graph_name.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_k2_graph_with_graph_name.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_k2_graph_with_graph_name' function (algorithm
 
\ref{lst:create_k2_graph_with_graph_name}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_k2_graph_with_graph_name.svg}

\section{...}
Working on graphs with a graph name

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Storing a graph with a graph name property as a .dot file}
\label{subsec:save_graph_with_graph_name_to_dot}

This works:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_graph_with_graph_name_to_dot.impl}

Storing a graph with a graph name as a .dot file
\index{Save graph with graph name to dot

\label{lst:save_graph_with_graph_name_to_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading a directed graph with a graph name property from a .dot file}
\label{subsec:load_directed_graph_with_graph_name_from_dot}

This will result in a directed graph with a name:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_graph_with_graph_name_from_dot.impl}

Loading a directed graph with a graph name from a .dot file
\index{Load directed custom edges and vertices graph from dot

\label{lst:load_directed_graph_with_graph_name_from_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading an undirected graph with a graph name property from a .dot file}
\label{subsec:load_undirected_graph_with_graph_name_from_dot}

This will result in an undirected graph with a name:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_graph_with_graph_name_from_dot.impl}

Loading an undirected graph with a graph name from a .dot file
\index{Load undirected custom edges and vertices graph from dot

\label{lst:load_undirected_graph_with_graph_name_from_dot}

\section{...}
Other graph functions
\label{sec:Other-graph-functions}

Some functions that did not fit in.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Encode a std::string to a Graphviz-friendly format}
\label{subsec:graphviz_encode}

You may want to use a label with spaces, comma's and/or quotes.
 Saving and loading these, will result in problem.
 This function replaces these special characters by a rare combination of
 ordinary characters.

\lstinputlisting[
  caption = ,
  label = lst:
]{graphviz_encode.impl}

Encode a std::string to a Graphviz-friendly format
\index{graphviz encode

\label{lst:graphviz_encode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Decode a std::string from a Graphviz-friendly format}
\label{subsec:graphviz_decode}

This function undoes the \verb;graphviz_encode' function (algorithm 
\ref{lst:graphviz_encode}

) and thus converts a Graphviz-friendly std::string to the original human-friend
ly std::string.

\lstinputlisting[
  caption = ,
  label = lst:
]{graphviz_decode.impl}

Decode a std::string from a Graphviz-friendly format to a human-friendly
 format
\index{graphviz decode

\label{lst:graphviz_decode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Check if a std::string is Graphviz-friendly}
\label{subsec:is_graphviz_friendly}

There are pieces where I check if a std::string is Graphviz-friendly.
 This is done only where it matters.
 If it is tested not to matter, \verb;is_graphviz_friendly' is absent.

\lstinputlisting[
  caption = ,
  label = lst:
]{is_graphviz_friendly.impl}

Check if a std::string is Graphviz-friendly
\index{is_graphviz_friendly

\label{lst:is_graphviz_friendly}

\section{...}
Misc functions

These are some function I needed for creating this tutorial.
 Although they are not important for working with graphs, I used these heavily.
 These functions may be compiler-dependent, platform-dependent and/or there
 may be superior alternatives.
 I just add them for completeness.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting a data type as a std::string}
\label{subsec:get_type_name}

This function will only work under GCC.
 I found this code at: 
\begin_inset Flex URL
status collapsed

http://stackoverflow.com/questions/1055452/c-get-name-of-type-in-template

 .
 Thanks to \verb;m-dudley' (Stack Overflow user page at 
\begin_inset Flex URL
status open

http://stackoverflow.com/users/111327/m-dudley

 ).

\lstinputlisting[
  caption = ,
  label = lst:
]{get_type_name.impl}

Getting a data type its name as a std::string
\index{Get type name

\label{lst:get_type_name}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Convert a .dot to .svg}
\label{subsec:convert_dot_to_svg}

All illustrations in this tutorial are created by converting .dot to a .svg
 (\verb;Scalable Vector Graphic') file.
 This function assumes the program \verb;dot' is installed, which is part of
 Graphviz.

\lstinputlisting[
  caption = ,
  label = lst:
]{convert_dot_to_svg.impl}

Convert a .dot file to a .svg
\index{Convert dot to svg

\label{lst:convert_dot_to_svg}

\verb;convert_dot_to_svg' makes a system call to the program \verb;dot' to convert
 the .dot file to an .svg file.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Check if a file exists}
\label{subsec:is_regular_file}

Not the most smart way perhaps, but it does only use the STL.

\lstinputlisting[
  caption = ,
  label = lst:
]{is_regular_file.impl}

Check if a file exists
\index{Is regular file

\label{lst:is_regular_file}

\section{...}
Errors

Some common errors.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Formed reference to void}
\label{subsec:formed_reference_to_void}

This compile-time error occurs when you create a graph without a certain
 property, then subsequently reading that property, as in algorithm 
\ref{lst:formed_reference_to_void}

: 

\lstinputlisting[
  caption = ,
  label = lst:
]{formed_reference_to_void.impl}

Creating the error \verb;formed reference to void'
\index{Formed reference to void

\label{lst:formed_reference_to_void}

In algorithm 
\ref{lst:formed_reference_to_void}

 a graph is created with vertices of no properties.
 Then the names of these vertices, which do not exists, are tried to be
 read.
 If you want to read the names of the vertices, supply a graph that has
 this property.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{No matching function for call to \verb;;clear_out_edges;}
\label{subsec:no_matching_function_for_call_to_clear_out_edges}

This compile-time error occurs when you want to clear the outward edges
 from a vertex in an undirected graph.
 

\lstinputlisting[
  caption = ,
  label = lst:
]{no_matching_function_for_call_to_clear_out_edges.impl}

Creating the error \verb;no matching function for call to clear_out_edges'
\index{No matching function for call to clear_out_edges

\label{lst:no_matching_function_for_call_to_clear_out_edges}

In algorithm 
\ref{lst:no_matching_function_for_call_to_clear_out_edges}

an undirected graph is created, a vertex descriptor is obtained, then itsout
 edges are tried to be cleared.Either use a directed graph (which has out
 edges), or use the \verb;boost::clear_vertex' function instead.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{No matching function for call to \verb;clear_in_edges;}
\label{subsec:no_matching_function_for_call_to_clear_in_edges}

See chapter 
\ref{subsec:no_matching_function_for_call_to_clear_out_edges}

.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Undefined reference to boost::detail::graph::read_graphviz_new}
\label{subsec:undefined_reference_to_read_graphviz_new}

\index{read_graphviz_new

\index{Undefined reference to read_graphviz_new

\index{read_graphviz_new, undefined reference

You will have to link
\index{link

 against the Boost.Graph and Boost.Regex libraries.
 In Qt Creator, this is achieved by adding these lines to your Qt Creator
 project file:

\begin_inset listings
inline false
status open

LIBS += -lboost_graph -lboost_regex 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Property not found: node_id}
\label{subsec:property_not_found_node_id}

\index{node_id

\index{Property not found

\index{Property not found: node_id

When loading a graph from file (as in chapter 
\ref{subsec:load_undirected_graph_from_dot}

) you will be using boost::read_graphviz
\index{boost::read_graphviz

.
 boost::read_graphviz
\index{boost::read_graphviz

 needs a third argument, of type boost::dynamic_properties
\index{boost::dynamic_properties

.
 When a graph does not have properties, do not use a default constructed
 version, but initialize with \verb;boost::ignore_other_properties'
\index{boost::ignore_other_properties

 as a constructor argument instead.
 Listing 
\ref{lst:property_not_found_node_id}

 shows how to trigger this run-time error.

\lstinputlisting[
  caption = ,
  label = lst:
]{property_not_found_node_id.impl}

Creating the error \verb;Property not found: node_id'
\index{Property not found: node_id

\label{lst:property_not_found_node_id}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Stream zeroes}

When loading a graph from a .dot file, in operator>>, I encountered reading
 zeroes, where I expected an XML formatted string:

\begin_inset listings
inline false
status open

std::istream& ribi::cmap::operator>>(std::istream& is, my_class& any_class)
 noexcept

{

  std::string s;

  is >> s; //s has an XML format

  \verb;assert;(s != }0});

  any_class = my_class(s);

  return is;

}

This was because I misconfigured the reader.
 I did (heavily simplified code):

\begin_inset listings
inline false
status open

graph load_from_dot(const std::string& dot_filename)

{

  std::ifstream f(dot_filename);

  graph g;

  boost::dynamic_properties dp;

  dp.property(}node_id}, get(boost::vertex_custom_type, g));

  dp.property(}label}, get(boost::vertex_custom_type, g));

  boost::read_graphviz(f,g,dp);

  return g;

}

Where it should have been:

\begin_inset listings
inline false
status open

graph load_from_dot(const std::string& dot_filename)

{

  std::ifstream f(dot_filename);

  graph g;

  boost::dynamic_properties dp(boost::ignore_other_properties);

  dp.property(}label}, get(boost::vertex_custom_type, g));

  boost::read_graphviz(f,g,dp);

  return g;

}

The explanation is that by setting the boost::dynamic_property \verb;node_id'
 to \verb;boost::vertex_custom_type', operator>> will receive the node indices.
 

An alternative, but less clean solution, is to let operator>> ignore the
 node indices:

\begin_inset listings
inline false
status open

std::istream& ribi::cmap::operator>>(std::istream& is, my_class& any_class)
 noexcept

{

  std::string s;

  is >> s; //s has an XML format

  if (!is_xml(s)) { //Ignore node index

    any_class_class = my_class(); 

  }

  else {

    any_class_class = my_class(s);

  }

  return is;

}

