
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Has a bundled vertex with a my_bundled_vertex}
\label{subsec:has_bundled_vertex_with_my_vertex}

Before modifying our vertices, let's first determine if we can find a vertex
 by its bundled type (\verb;my_bundled_vertex;) in a graph.
 After obtain the vertex iterators, we can dereference each these to obtain
 the vertex descriptors and then compare each vertex its \verb;my_bundled_vertex;
 with the one desired.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_vertex_with_my_vertex.impl}

Find if there is vertex with a certain my_bundled_vertex
\index{Has bundled vertex with my_vertex}

\label{lst:has_bundled_vertex_with_my_vertex}

This function can be demonstrated as in algorithm 
\ref{lst:has_bundled_vertex_with_my_vertex_demo}

, where a certain my_bundled_vertex cannot be found in an empty graph.
 After adding the desired my_bundled_vertex, it is found.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_vertex_with_my_vertex_demo.impl}

Demonstration of the \verb;has_bundled_vertex_with_my_vertex' function
\label{lst:has_bundled_vertex_with_my_vertex_demo}

Note that this function only finds if there is at least one bundled vertex
 with that my_bundled_vertex: it does not tell how many bundled vertices
 with that my_bundled_vertex exist in the graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find a bundled vertex with a certain my_bundled_vertex}
\label{subsec:find_bundled_vertex_with_my_vertex}

Where STL functions work with iterators, here we obtain a vertex descriptor
 (see chapter 
\ref{subsec:Vertex-descriptors}

) to obtain a handle to the desired vertex.
 Listing 
\ref{lst:find_first_bundled_vertex_with_my_vertex}

 shows how to obtain a vertex descriptor to the first vertex found with
 a specific \verb;my_bundled_vertex; value.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_vertex_with_my_vertex.impl}

Find the first vertex with a certain my_bundled_vertex
\index{Find first bundled vertex with my_vertex}

\label{lst:find_first_bundled_vertex_with_my_vertex}

With the vertex descriptor obtained, one can read and modify the vertex
 and the edges surrounding it.
 Listing 
\ref{lst:find_first_bundled_vertex_with_my_vertex_demo}

 shows some examples of how to do so.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_vertex_with_my_vertex_demo.impl}

Demonstration of the \verb;find_first_bundled_vertex_with_my_vertex' function
\label{lst:find_first_bundled_vertex_with_my_vertex_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Get a bundled vertex its \verb;my_bundled_vertex;}
\label{subsec:get_bundled_vertex_my_vertex}

To obtain the \verb;my_bundled_vertex; from a vertex descriptor is simple:

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_vertex.impl}

Get a bundled vertex its my_vertex from its vertex descriptor
\index{Get bundled vertex my_bundled_vertex

\label{lst:get_bundled_vertex_my_vertex}

One can just use the graph as a property map and let it be looked-up.

To use \verb;get_bundled_vertex_my_vertex', one first needs to obtain a vertex
 descriptor.
 Listing 
\ref{lst:get_bundled_vertex_my_vertex_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_vertex_demo.impl}

Demonstration if the \verb;get_bundled_vertex_my_vertex' function
\label{lst:get_bundled_vertex_my_vertex_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set a bundled vertex its my_vertex}
\label{subsec:set_bundled_vertex_my_vertex}

If you know how to get the \verb;my_bundled_vertex; from a vertex descriptor,
 setting it is just as easy, as shown in algorithm 
\ref{lst:set_bundled_vertex_my_vertex}

.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_vertex.impl}

Set a bundled vertex its my_vertex from its vertex descriptor
\index{Set vertex my_vertex

\label{lst:set_bundled_vertex_my_vertex}

To use \verb;set_bundled_vertex_my_vertex', one first needs to obtain a vertex
 descriptor.
 Listing 
\ref{lst:set_bundled_vertex_my_vertex_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_vertex_demo.impl}

Demonstration if the \verb;set_bundled_vertex_my_vertex' function
\label{lst:set_bundled_vertex_my_vertex_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Setting all bundled vertices' my_vertex objects}
\label{subsec:set_bundled_vertex_my_vertexes}

When the vertices of a graph are \verb;my_bundled_vertex; objects, one can set
 these as such:

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_vertexes.impl}

Setting the bundled vertices' \verb;my_bundled_vertex;-es
\index{Set bundled vertex my_bundled_vertexes

\label{lst:set_bundled_vertex_my_vertexes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Storing a graph with bundled vertices as a .dot}
\label{subsec:save_bundled_vertices_graph_to_dot}

If you used the \verb;create_bundled_vertices_k2_graph' function (algorithm 
\ref{lst:create_bundled_vertices_k2_graph}

) to produce a 
$K_{2}$

 graph with vertices associated with \verb;my_bundled_vertex; objects, you can
 store these with algorithm 
\ref{lst:save_bundled_vertices_graph_to_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_bundled_vertices_graph_to_dot.impl}

Storing a graph with bundled vertices as a .dot file
\index{Save bundled vertices graph to dot

\label{lst:save_bundled_vertices_graph_to_dot}

This code looks small, because we call the \verb;make_bundled_vertices_writer'
 function, which is shown in algorithm 
\ref{lst:make_bundled_vertices_writer}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{make_bundled_vertices_writer.impl}

The \verb;make_bundled_vertices_writer' function
\index{make_bundled_vertices_writer

\label{lst:make_bundled_vertices_writer}

Also this function is forwarding the real work to the \verb;bundled_vertices_writer',
 shown in algorithm 
\ref{lst:bundled_vertices_writer}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{bundled_vertices_writer.impl}

The \verb;bundled_vertices_writer' function
\index{bundled_vertices_writer

\label{lst:bundled_vertices_writer}

Here, some interesting things are happening: the writer needs the bundled
 property maps to work with and thus copies the whole graph to its internals.
 I have chosen to map the \verb;my_bundled_vertex; member variables to Graphviz
 attributes (see chapter 
\ref{subsec:Graphviz-attributes}

 for most Graphviz attributes) as shown in table 
\ref{tab:Mapping-of-my_bundled_vertex-to-Graphviz-attributes}

:

\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_inset Tabular
<lyxtabular version=}3} rows=}5} columns=}4}>
<features tabularvalignment=}middle}>
<column alignment=}center} valignment=}top}>
<column alignment=}center} valignment=}top}>
<column alignment=}center} valignment=}top}>
<column alignment=}center} valignment=}top}>
<row>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

my_bundled_vertex variable

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

C++ data type

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

Graphviz data type

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

Graphviz attribute

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_name

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

std::string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

label

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_description

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

std::string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

string

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

comment

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_x

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

width

</cell>
</row>
<row>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

m_y

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} usebox=}none}>
\begin_inset Text

double

</cell>
<cell alignment=}center} valignment=}top} topline=}true} bottomline=}true} leftline=}true} rightline=}true} usebox=}none}>
\begin_inset Text

height

</cell>
</row>
</lyxtabular>

Mapping of my_bundled_vertex member variable and Graphviz attributes
\label{tab:Mapping-of-my_bundled_vertex-to-Graphviz-attributes}

Important in this mapping is that the C++ and the Graphviz data types match.
 I also chose attributes that matched as closely as possible.

The writer also encodes the std::string of the name and description to a
 Graphviz-friendly format.
 When loading the .dot file again, this will have to be undone again.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading a directed graph with bundled vertices from a .dot}
\label{subsec:load_directed_bundled_vertices_graph_from_dot}

When loading a graph from file, one needs to specify a type of graph.
 In this example, an directed graph with bundled vertices is loaded, as
 shown in algorithm 
\ref{lst:load_directed_bundled_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_vertices_graph_from_dot.impl}

Loading a directed graph with bundled vertices from a .dot file
\index{Load directed bundled vertices graph from dot

\label{lst:load_directed_bundled_vertices_graph_from_dot}

In this algorithm, first it is checked if the file to load exists.
 Then an empty directed graph is created, to save typing the typename explicitly.

Then a boost::dynamic_properties
\index{boost::dynamic_properties

 is created with its default constructor, after which we set it to follow
 the same mapping as in the previous chapter.
 From this and the empty graph, \verb;boost::read_graphviz;
\index{boost::read_graphviz

 is called to build up the graph.

At the moment the graph is created, all \verb;my_bundled_vertex; their names
 and description are in a Graphviz-friendly format.
 By obtaining all vertex iterators and vertex descriptors, the encoding
 is made undone.

Listing 
\ref{lst:load_directed_bundled_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_directed_bundled_vertices_graph_from_dot' function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_directed_bundled_vertices_graph_from_dot' function
\label{lst:load_directed_bundled_vertices_graph_from_dot_demo}

This demonstration shows how the Markov chain is created using the \verb;create_bundl
ed_vertices_markov_chain' function (algorithm 
\ref{lst:create_bundled_vertices_markov_chain}

), saved and then loaded.
 The loaded graph is checked to be the same as the original.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading an undirected graph with bundled vertices from a .dot}
\label{subsec:load_undirected_bundled_vertices_graph_from_dot}

When loading a graph from file, one needs to specify a type of graph.
 In this example, an undirected graph with bundled vertices is loaded, as
 shown in algorithm 
\ref{lst:load_undirected_bundled_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_vertices_graph_from_dot.impl}

Loading an undirected graph with bundled vertices from a .dot file
\index{Load undirected bundled vertices graph from dot

\label{lst:load_undirected_bundled_vertices_graph_from_dot}

The only difference with loading a directed graph, is that the initial empty
 graph is undirected instead.
 Chapter 
\ref{subsec:load_directed_bundled_vertices_graph_from_dot}

 describes the rationale of this function.
 

Listing 
\ref{lst:load_undirected_bundled_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_undirected_bundled_vertices_graph_from_dot'
 function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_undirected_bundled_vertices_graph_from_dot' function
\label{lst:load_undirected_bundled_vertices_graph_from_dot_demo}

This demonstration shows how 
$K_{2}$

 with bundled vertices is created using the \verb;create_bundled_vertices_k2_graph'
 function (algorithm 
\ref{lst:create_bundled_vertices_k2_graph}

), saved and then loaded.
 The loaded graph is checked to be the same as the original.

\section{...}
Building graphs with bundled edges and vertices

Up until now, the graphs created have had only bundled vertices.
 In this chapter, graphs will be created, in which both the edges and vertices
 have a bundled \verb;my_bundled_edge' and \verb;my_bundled_edge' type
\footnote{I do not intend to be original in naming my data types

.

\begin{itemize}
An empty directed graph that allows for bundled edges and vertices: see
 chapter 
\ref{subsec:create_empty_directed_bundled_edges_and_vertices_graph}

\begin{itemize}
An empty undirected graph that allows for bundled edges and vertices: see
 chapter 
\ref{subsec:create_empty_undirected_bundled_edges_and_vertices_graph}

\begin{itemize}
A two-state Markov chain with bundled edges and vertices: see chapter 
\ref{subsec:create_bundled_edges_and_vertices_markov_chain}

\begin{itemize}
$K_{3}$

with bundled edges and vertices: see chapter 
\ref{subsec:create_bundled_edges_and_vertices_k3}

In the process, some basic (sometimes bordering trivial) functions are shown:

\begin{itemize}
Creating the \verb;my_bundled_edge' class: see chapter 
\ref{subsec:my_bundled_edge}

\begin{itemize}
Adding a bundled \verb;my_bundled_edge': see chapter 
\ref{subsec:add_bundled_edge}

These functions are mostly there for completion and showing which data types
 are used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating the bundled edge class}
\label{subsec:my_bundled_edge}

In this example, I create a \verb;my_bundled_edge' class.
 Here I will show the header file of it, as the implementation of it is
 not important yet.

\lstinputlisting[
  caption = ,
  label = lst:
]{my_bundled_edge.impl}

Declaration of my_bundled_edge
\index{my_bundled_edge

\index{my_bundled_edge.h

\index{my_bundled_edge declaration

\index{Declaration, my_bundled_edge

\label{lst:my_bundled_edge_h}

my_bundled_edge is a class that has multiple properties: two doubles \verb;m_width'
 (\verb;m_
\index{m_

' stands for member
\index{member

) and \verb;m_height', and two std::strings m_name and m_description.\verb;my_bundled_edge'
 is copyable, but cannot trivially be converted to a \verb;std::string.' \verb;my_bundled_e
dge' is comparable for equality (that is, operator== is defined).

\verb;my_bundled_edge' does not have to have the stream operators defined for
 file I/O, as this goes via the public member variables.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty directed graph with bundled edges and vertices}
\label{subsec:create_empty_directed_bundled_edges_and_vertices_graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_bundled_edges_and_vertices_graph.impl}

Creating an empty directed graph with bundled edges and vertices
\index{Create empty directed bundled edges and vertices graph

\label{lst:create_empty_directed_bundled_edges_and_vertices_graph}

This code is very similar to the code described in chapter 
\ref{subsec:create_empty_directed_custom_vertices_graph}

, except that there is a new, fifth template argument:

\begin{verbatim}\end{verbatim}
boost::property<boost::edge_bundled_type_t, my_edge>

\index{boost::property

\index{boost::edge_bundled_type_t

\index{my_edge

This can be read as: 
\begin{quote}
edges have the property \verb;boost::edge_bundled_type_t', which is of data type
 \verb;my_bundled_edge'
\end{quote}
.
 Or simply: 
\begin{quote}
edges have a bundled type called my_bundled_edge
\end{quote}
.

Demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_bundled_edges_and_vertices_graph_demo.impl}

Demonstration of the \verb;create_empty_directed_bundled_edges_and_vertices_graph'
 function
\label{lst:create_empty_directed_bundled_edges_and_vertices_graph_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty undirected graph with bundled edges and vertices}
\label{subsec:create_empty_undirected_bundled_edges_and_vertices_graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_bundled_edges_and_vertices_graph.impl}

Creating an empty undirected graph with bundled edges and vertices
\index{Create empty undirected bundled edges and vertices graph

\label{lst:create_empty_undirected_bundled_edges_and_vertices_graph}

This code is very similar to the code described in chapter 
\ref{subsec:create_empty_directed_bundled_edges_and_vertices_graph}

, except that the directness (the third template argument) is undirected
 (due to the boost::undirectedS
\index{boost::undirectedS

).

Demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_bundled_edges_and_vertices_graph_demo.impl}

Demonstration of the \verb;create_empty_undirected_bundled_edges_and_vertices_graph'
 function
\label{lst:create_empty_undirected_bundled_edges_and_vertices_graph_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Add a bundled edge}
\label{subsec:add_bundled_edge}

Adding a bundled edge is very similar to adding a named edge (chapter 
\ref{subsec:add_named_edge}

).

\lstinputlisting[
  caption = ,
  label = lst:
]{add_bundled_edge.impl}

Add a bundled edge
\index{Add bundled edge

\label{lst:add_bundled_edge}

When having added a new (abstract) edge to the graph, the edge descriptor
 is used to set the my_edge in the graph.

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{add_bundled_edge_demo.impl}

Demo of \verb;add_bundled_edge'
\label{lst:add_bundled_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting the bundled edges my_edges}
\label{subsec:get_bundled_edge_my_edges}

When the edges of a graph are \verb;my_bundled_edge' objects, one can extract
 these all as such:

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_edges.impl}

Get the edges' my_bundled_edges
\index{Get edge my_bundled_edges

\label{lst:get_bundled_edge_my_edges}

The \verb;my_bundled_edge' object associated with the edges are obtained from
 the graph its property_map and then put into a std::vector.

Note: the order of the my_bundled_edge objects may be different after saving
 and loading.

When trying to get the edges' my_bundled_edge objects from a graph without
 bundled edges objects associated, you will get the error \verb;formed reference
 to void' (see chapter 
\ref{subsec:formed_reference_to_void}

).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating a Markov-chain with bundled edges and vertices}
\label{subsec:create_bundled_edges_and_vertices_markov_chain}

\subsection{Graph}

Figure 
\ref{fig:bundled_edges_and_vertices_markov_chain}

 shows the graph that will be reproduced:

\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_inset ERT
status open

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=9cm, semithick
]   

  
\tikzstyle{every state}=[]

  
\node[state] (A) 

    {Stable,Right, 1.0, 2.0};   

  
\node[state] (B) [right of=A] 

    {Not unstable,Not left, 3.0, 4.0}

  ;   

  
\path (A) edge [loop above] node {Red,Heat,1,2} (A)

        (A) edge [bend  left] node {Orange,Lose heat,3,4} (B)

        (B) edge [bend  left] node {Yellow cold,Heat,4,5} (A)

        (B) edge [loop above] node {Green cols,Stay cool,6,7} (B); 

\end{tikzpicture}

A two-state Markov chain where the edges and vertices have bundled properties.
 The edges' and vertices' properties are nonsensical
\label{fig:bundled_edges_and_vertices_markov_chain}

\subsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with bundled edges and
 vertices:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_markov_chain.impl}

Creating the two-state Markov chain as depicted in figure 
\ref{fig:bundled_edges_and_vertices_markov_chain}

\index{Create bundled edges and vertices Markov chain

\label{lst:create_bundled_edges_and_vertices_markov_chain}

\subsection{Creating such a graph

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_markov_chain_demo.impl}

Demo of the \verb;create_bundled_edges_and_vertices_markov_chain' function (algorithm
 
\ref{lst:create_bundled_edges_and_vertices_markov_chain}

)
\label{lst:create_bundled_edges_and_vertices_markov_chain_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_markov_chain.dot}

.dot file created from the \verb;create_bundled_edges_and_vertices_markov_chain'
 function (algorithm 
\ref{lst:create_bundled_edges_and_vertices_markov_chain}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_bundled_edges_and_vertices_markov_chain.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_bundled_edges_and_vertices_markov_chain.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_bundled_edges_and_vertices_markov_chain'
 function (algorithm 
\ref{lst:create_custom_vertices_markov_chain}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_bundled_edges_and_vertices_markov_chain.svg}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating $K_{3}$  with bundled edges and vertices}
\label{subsec:create_bundled_edges_and_vertices_k3}

Instead of using edges with a name, or other properties, here we use a bundled
 edge class called \verb;my_bundled_edge'.

\subsection{Graph}

We reproduce the 
$K_{3}$

 with named edges and vertices of chapter 
\ref{subsec:create_named_edges_and_vertices_k3}

 , but with our bundled edges and vertices instead:

\begin{figure}
  \begin{tikzpicture}
    ...
  \end{tikzpicture}
  \caption{.}
  \label{fig:.}
\end{figure}
\
draw[] 

  (2,4) node[draw=black,fill=white,shape=circle,text=black] {Red,Not green,1,2}
 

   -- (5,2) node[anchor=west] {Oxygen,Air,1,2} 

   -- (8,0) node[draw=black,fill=white,shape=circle,text=black] {Light red,Not
 dark,3,4} 

   -- (4,0) node[anchor=north] {Helium,From tube,3,4} 

   -- (0,0) node[draw=black,fill=white,shape=circle,text=black] {Orange,Orange,5
,6} 

   -- (1,2) node[anchor=east] {Stable temperature,Here,5,6} 

   -- (2,4)

;

$K_{3}$

: a fully connected graph with three named edges and vertices 
\label{fig:create_bundled_edges_and_vertices_k3}

\subsection{Function to create such a graph}

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_k3_graph.impl}

Creating 
$K_{3}$

 as depicted in figure 
\ref{fig:named_edges_and_vertices_k3}

\index{Create bundled edges and vertices K3 graph

\label{lst:create_bundled_edges_and_vertices_k3_graph}

Most of the code is a slight modification of algorithm 
\ref{lst:create_named_edges_and_vertices_k3_graph}

.
 In the end, the my_edges and my_vertices are obtained as the graph its
 property_map and set with the \verb;my_bundled_edge' and \verb;my_bundled_vertex;
 objects.

\subsection{Creating such a graph

Here is the demo:

\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_k3_graph_demo.impl}

Demo of the \verb;create_bundled_edges_and_vertices_k3_graph' function (algorithm
 
\ref{lst:create_bundled_edges_and_vertices_k3_graph}

)
\label{lst:create_bundled_edges_and_vertices_k3_graph_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_bundled_edges_and_vertices_k3_graph.dot}

.dot file created from the \verb;create_bundled_edges_and_vertices_markov_chain'
 function (algorithm 
\ref{lst:create_bundled_edges_and_vertices_k3_graph}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_bundled_edges_and_vertices_k3_graph.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_bundled_edges_and_vertices_k3_graph.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_bundled_edges_and_vertices_k3_graph' function
 (algorithm 
\ref{lst:create_custom_vertices_markov_chain}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_bundled_edges_and_vertices_k3_graph.svg}

\section{...}
Working on graphs with bundled edges and vertices

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Has a my_bundled_edge}
\label{subsec:has_bundled_edge_with_my_edge}

Before modifying our edges, let's first determine if we can find an edge
 by its bundled type (\verb;my_bundled_edge') in a graph.
 After obtaining a my_bundled_edge map, we obtain the edge iterators, dereferenc
e these to obtain the edge descriptors and then compare each edge its my_bundled
_edge with the one desired.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_edge_with_my_edge.impl}

Find if there is a bundled edge with a certain my_bundled_edge
\index{Has bundled edge with my_bundled_edge

\label{lst:has_bundled_edge_with_my_edge}

This function can be demonstrated as in algorithm 
\ref{lst:has_bundled_edge_with_my_edge_demo}

, where a certain \verb;my_bundled_edge' cannot be found in an empty graph.
 After adding the desired my_bundled_edge, it is found.

\lstinputlisting[
  caption = ,
  label = lst:
]{has_bundled_edge_with_my_edge_demo.impl}

Demonstration of the \verb;has_bundled_edge_with_my_edge' function
\label{lst:has_bundled_edge_with_my_edge_demo}

Note that this function only finds if there is at least one edge with that
 my_bundled_edge: it does not tell how many edges with that my_bundled_edge
 exist in the graph.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Find a my_bundled_edge}
\label{subsec:find_first_bundled_edge_with_my_edge}

Where STL functions work with iterators, here we obtain an edge descriptor
 (see chapter 
\ref{subsec:Edge-descriptors}

) to obtain a handle to the desired edge.
 Listing 
\ref{lst:find_first_bundled_edge_with_my_edge}

 shows how to obtain an edge descriptor to the first edge found with a specific
 my_bundled_edge value.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_edge_with_my_edge.impl}

Find the first bundled edge with a certain my_bundled_edge
\index{Find first bundled edge with my_bundled_edge

\label{lst:find_first_bundled_edge_with_my_edge}

With the edge descriptor obtained, one can read and modify the edge and
 the vertices surrounding it.
 Listing 
\ref{lst:find_first_bundled_edge_with_my_edge_demo}

 shows some examples of how to do so.

\lstinputlisting[
  caption = ,
  label = lst:
]{find_first_bundled_edge_with_my_edge_demo.impl}

Demonstration of the \verb;find_first_bundled_edge_with_my_edge' function
\label{lst:find_first_bundled_edge_with_my_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Get an edge its my_bundled_edge}
\label{subsec:get_bundled_edge_my_edge}

To obtain the my_bundled_edge from an edge descriptor, one needs to pull
 out the my_bundled_edges map and then look up the my_edge of interest.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_edge.impl}

Get a vertex its my_bundled_vertex from its vertex descriptor
\index{Get my_bundled_edge

\label{lst:get_bundled_edge_my_edge}

To use \verb;get_my_bundled_edge', one first needs to obtain an edge descriptor.
 Listing 
\ref{lst:get_bundled_edge_my_edge_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_my_bundled_edge_demo.impl}

Demonstration if the \verb;get_my_bundled_edge' function
\label{lst:get_bundled_edge_my_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set an edge its my_bundled_edge}
\label{subsec:set_bundled_edge_my_edge}

If you know how to get the my_bundled_edge from an edge descriptor, setting
 it is just as easy, as shown in algorithm 
\ref{lst:set_bundled_edge_my_edge}

.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_edge.impl}

Set a bundled edge its my_bundled_edge from its edge descriptor
\index{Set bundled edge my_bundled_edge

\label{lst:set_bundled_edge_my_edge}

To use \verb;set_bundled_edge_my_edge', one first needs to obtain an edge descriptor.
 Listing 
\ref{lst:set_bundled_edge_my_edge_demo}

 shows a simple example.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_my_bundled_edge_demo.impl}

Demonstration if the \verb;set_bundled_edge_my_edge' function
\label{lst:set_bundled_edge_my_edge_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Storing a graph with bundled edges and vertices as a .dot}
\label{subsec:save_bundled_edges_and_vertices_graph_to_dot}

\index{Save graph with bundled edges and vertices as .dot

\index{Create .dot from graph with bundled edges and vertices

 

If you used the \verb;create_bundled_edges_and_vertices_k3_graph' function (algorithm
 
\ref{lst:create_bundled_edges_and_vertices_k3_graph}

) to produce a 
$K_{3}$

graph with edges and vertices associated with my_bundled_edge and my_bundled_ver
tex objects, you can store these my_bundled_edges and my_bundled_vertex-es
 additionally with algorithm 
\ref{lst:save_bundled_edges_and_vertices_graph_to_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_bundled_edges_and_vertices_graph_to_dot.impl}

Storing a graph with bundled edges and vertices as a .dot file
\index{Save bundled edges and vertices graph to dot

\label{lst:save_bundled_edges_and_vertices_graph_to_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load a directed graph with bundled edges and vertices from a .dot file}
\label{subsec:sub:load_directed_bundled_edges_and_vertices_graph_from_dot}

When loading a graph from file, one needs to specify a type of graph.
 In this example, an directed graph with bundled edges and vertices is loaded,
 as shown in algorithm 
\ref{lst:load_directed_bundled_edges_and_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_edges_and_vertices_graph_from_dot.impl}

Loading a directed graph with bundled edges and vertices from a .dot file
\index{Load directed bundled edges and vertices graph from dot

\label{lst:load_directed_bundled_edges_and_vertices_graph_from_dot}

In this algorithm, first it is checked if the file to load exists.
 Then an empty directed graph is created.
 Next to this, a boost::dynamic_properties
\index{boost::dynamic_properties

 is created with its default constructor, after which we direct the boost::dynam
ic_properties
\index{boost::dynamic_properties

 to find a \verb;node_id' and \verb;label' in the vertex name map, \verb;edge_id' and \verb;label'
 to the edge name map.
 From this and the empty graph, \verb;boost::read_graphviz;
\index{boost::read_graphviz

 is called to build up the graph.

Listing 
\ref{lst:load_directed_bundled_edges_and_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_directed_bundled_edges_and_vertices_graph_from_dot'
 function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_bundled_edges_and_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_directed_bundled_edges_and_vertices_graph_from_dot'fu
nction
\label{lst:load_directed_bundled_edges_and_vertices_graph_from_dot_demo}

This demonstration shows how the Markov chain is created using the \verb;create_bundl
ed_edges_and_vertices_markov_chain' function (algorithm 
\ref{lst:create_bundled_edges_and_vertices_markov_chain}

), saved and then loaded.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Load an undirected graph with bundled edges and vertices from a .dot file}
\label{subsec:load_undirected_bundled_edges_and_vertices_graph_from_dot}

\index{Load undirected graph with bundled edges and vertices from .dot

\index{Create undirected graph with bundled edges and vertices from .dot

When loading a graph from file, one needs to specify a type of graph.
 In this example, an undirected graph with bundled edges and vertices is
 loaded, as shown in algorithm 
\ref{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot}

:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_edges_and_vertices_graph_from_dot.impl}

Loading an undirected graph with bundled edges and vertices from a .dot file
\index{Load undirected bundled edges and vertices graph from dot

\label{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot}

The only difference with loading a directed graph, is that the initial empty
 graph is undirected instead.
 Chapter 
\ref{subsec:sub:load_directed_bundled_edges_and_vertices_graph_from_dot}

 describes the rationale of this function.
 

Listing 
\ref{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot_demo}

 shows how to use the \verb;load_undirected_bundled_vertices_graph_from_dot'
 function:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_bundled_edges_and_vertices_graph_from_dot_demo.impl}

Demonstration of the \verb;load_undirected_bundled_edges_and_vertices_graph_from_dot'
function
\label{lst:load_undirected_bundled_edges_and_vertices_graph_from_dot_demo}

This demonstration shows how 
$K_{2}$

 with bundled vertices is created using the \verb;create_bundled_vertices_k2_graph'
 function (algorithm 
\ref{lst:create_custom_vertices_k2_graph}

), saved and then loaded.
 The loaded graph is checked to be a graph similar to the original.

\section{...}
Building graphs with a graph name
\label{sec:Building-graphs-with-a-graph-name}

Up until now, the graphs created have had no properties themselves.
 Sure, the edges and vertices have had properties, but the graph itself
 has had none.
 Until now.

In this chapter, graphs will be created with a graph name of type std::string

\begin{itemize}
An empty directed graph with a graph name: see chapter 

\begin{itemize}
An empty undirected graph with a graph name: see chapter 

\begin{itemize}
A two-state Markov chain with a graph name: see chapter

\begin{itemize}
$K_{3}$

with a graph name: see chapter 

In the process, some basic (sometimes bordering trivial) functions are shown:

\begin{itemize}
Getting a graph its name: see chapter 

\begin{itemize}
Setting a graph its name: see chapter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty directed graph with a graph name property}
\label{subsec:create_empty_directed_graph_with_graph_name}

Listing 
\ref{lst:create_empty_directed_graph_with_graph_name}

 shows the function to create an empty directed graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_graph_with_graph_name.impl}

Creating an empty directed graph with a graph name
\index{Create empty directed graph with graph name

\label{lst:create_empty_directed_graph_with_graph_name}

This \verb;boost::adjacency_list; is of the following type:

\begin{itemize}
the first \verb;boost::vecS'
\index{boost::vecS

: select (that is what the \verb;S
\index{S

' means) that out edges are stored in a std::vector.
 This is the default way.

\begin{itemize}
the second \verb;boost::vecS'
\index{boost::vecS

: select that the graph vertices are stored in a std::vector.
 This is the default way.

\begin{itemize}
\verb;boost::directedS'
\index{boost::directedS

: select that the graph is directed.
 This is the default selectedness

\begin{itemize}
the first \verb;boost::no_property'
\index{boost::no_property

: the vertices have no properties.
 This is the default (non-)property

\begin{itemize}
the second \verb;boost::no_property'
\index{boost::no_property

: the vertices have no properties.
 This is the default (non-)property

\begin{itemize}
\verb;boost::property<boost::graph_name_t, std::string>'
\index{boost::property

\index{boost::graph_name_t

: the graph itself has a single property: its boost::graph_name
\index{boost::graph_name

 has type std::string

Listing 
\ref{lst:create_empty_directed_graph_with_graph_name_demo}

 demonstrates the \verb;create_empty_directed_graph_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_directed_graph_with_graph_name_demo.impl}

Demonstration of \verb;create_empty_directed_graph_with_graph_name'
\label{lst:create_empty_directed_graph_with_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an empty undirected graph with a graph name property}
\label{subsec:create_empty_undirected_graph_with_graph_name}

Listing 
\ref{lst:create_empty_undirected_graph_with_graph_name}

 shows the function to create an empty undirected graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_graph_with_graph_name.impl}

Creating an empty undirected graph with a graph name
\index{Create empty undirected graph with graph name

\label{lst:create_empty_undirected_graph_with_graph_name}

This code is very similar to the code described in chapter 
\ref{lst:create_empty_directed_graph_with_graph_name}

, except that the directness (the third template argument) is undirected
 (due to the boost::undirectedS
\index{boost::undirectedS

).

Listing 
\ref{lst:create_empty_undirected_graph_with_graph_name_demo}

 demonstrates the \verb;create_empty_undirected_graph_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_empty_undirected_graph_with_graph_name_demo.impl}

Demonstration of \verb;create_empty_undirected_graph_with_graph_name'
\label{lst:create_empty_undirected_graph_with_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Get a graph its name property}
\label{subsec:get_graph_name}

\lstinputlisting[
  caption = ,
  label = lst:
]{get_graph_name.impl}

Get a graph its name
\index{Get graph name

\label{lst:get_graph_name}

Listing 
\ref{lst:get_graph_name_demo}

 demonstrates the \verb;get_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{get_graph_name_demo.impl}

Demonstration of \verb;get_graph_name'
\label{lst:get_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set a graph its name property}
\label{subsec:set_graph_name}

\lstinputlisting[
  caption = ,
  label = lst:
]{set_graph_name.impl}

Set a graph its name
\index{Set graph name

\label{lst:set_graph_name}

Listing 
\ref{lst:set_graph_name_demo}

 demonstrates the \verb;set_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{set_graph_name_demo.impl}

Demonstration of \verb;set_graph_name'
\label{lst:set_graph_name_demo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create a directed graph with a graph name property}
\label{subsec:create_markov_chain_with_graph_name}

\subsection{Graph}

See figure 
\ref{fig:markov_chain}

.

\subsection{Function to create such a graph}

Listing 
\ref{lst:create_markov_chain_with_graph_name}

 shows the function to create an empty directed graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_markov_chain_with_graph_name.impl}

Creating a two-state Markov chain with a graph name
\index{Create Markov chain with graph name

\label{lst:create_markov_chain_with_graph_name}

\subsection{Creating such a graph}

Listing 
\ref{lst:create_markov_chain_with_graph_name_demo}

 demonstrates the \verb;create_markov_chain_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_markov_chain_with_graph_name_demo.impl}

Demonstration of \verb;create_markov_chain_with_graph_name'
\label{lst:create_markov_chain_with_graph_name_demo}

\subsection{The .dot file produced}


\lstinputlisting[
  caption = ,
  label = lst:
]{create_markov_chain_with_graph_name.dot}

.dot file created from the \verb;create_markov_chain_with_graph_name' function
 (algorithm 
\ref{lst:create_markov_chain_with_graph_name}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_markov_chain_with_graph_name.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_markov_chain_with_graph_name.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_markov_chain_with_graph_name' function
 (algorithm 
\ref{lst:create_markov_chain_with_graph_name}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_markov_chain_with_graph_name.svg}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create an undirected graph with a graph name property}
\label{subsec:create_k2_graph_with_graph_name}

\subsection{Graph}

See figure 
\ref{fig:k2_graph}

.

\subsection{Function to create such a graph}

Listing 
\ref{lst:create_k2_graph_with_graph_name}

 shows the function to create K2 graph with a graph name.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_k2_graph_with_graph_name.impl}

Creating a K2 graph with a graph name
\index{Create K2 graph with graph name

\label{lst:create_k2_graph_with_graph_name}

\subsection{Creating such a graph

Listing 
\ref{lst:create_k2_graph_with_graph_name_demo}

 demonstrates the \verb;create_k2_graph_with_graph_name' function.

\lstinputlisting[
  caption = ,
  label = lst:
]{create_k2_graph_with_graph_name_demo.impl}

Demonstration of \verb;create_k2_graph_with_graph_name'
\label{lst:create_k2_graph_with_graph_name_demo}

\subsection{The .dot file produced


\lstinputlisting[
  caption = ,
  label = lst:
]{create_k2_graph_with_graph_name.dot}

.dot file created from the \verb;create_k2_graph_with_graph_name' function (algorithm
 
\ref{lst:create_k2_graph_with_graph_name}

), converted from graph to .dot file using algorithm 
\ref{lst:save_graph_to_dot}

\label{lst:create_k2_graph_with_graph_name.dot}

\subsection{The .svg file produced}

\begin{figure}[!htbp]
  \includegraphics[]{create_k2_graph_with_graph_name.svg}
  \caption{
    .
  }
  \label{fig:.}
\end{figure}

.svg file created from the \verb;create_k2_graph_with_graph_name' function (algorithm
 
\ref{lst:create_k2_graph_with_graph_name}

) its .dot file, converted from .dot file to .svg using algorithm 
\ref{lst:convert_dot_to_svg}

\label{fig:create_k2_graph_with_graph_name.svg}

\section{...}
Working on graphs with a graph name

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Storing a graph with a graph name property as a .dot file}
\label{subsec:save_graph_with_graph_name_to_dot}

This works:

\lstinputlisting[
  caption = ,
  label = lst:
]{save_graph_with_graph_name_to_dot.impl}

Storing a graph with a graph name as a .dot file
\index{Save graph with graph name to dot

\label{lst:save_graph_with_graph_name_to_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading a directed graph with a graph name property from a .dot file}
\label{subsec:load_directed_graph_with_graph_name_from_dot}

This will result in a directed graph with a name:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_directed_graph_with_graph_name_from_dot.impl}

Loading a directed graph with a graph name from a .dot file
\index{Load directed custom edges and vertices graph from dot

\label{lst:load_directed_graph_with_graph_name_from_dot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loading an undirected graph with a graph name property from a .dot file}
\label{subsec:load_undirected_graph_with_graph_name_from_dot}

This will result in an undirected graph with a name:

\lstinputlisting[
  caption = ,
  label = lst:
]{load_undirected_graph_with_graph_name_from_dot.impl}

Loading an undirected graph with a graph name from a .dot file
\index{Load undirected custom edges and vertices graph from dot

\label{lst:load_undirected_graph_with_graph_name_from_dot}

\section{...}
Other graph functions
\label{sec:Other-graph-functions}

Some functions that did not fit in.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Encode a std::string to a Graphviz-friendly format}
\label{subsec:graphviz_encode}

You may want to use a label with spaces, comma's and/or quotes.
 Saving and loading these, will result in problem.
 This function replaces these special characters by a rare combination of
 ordinary characters.

\lstinputlisting[
  caption = ,
  label = lst:
]{graphviz_encode.impl}

Encode a std::string to a Graphviz-friendly format
\index{graphviz encode

\label{lst:graphviz_encode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Decode a std::string from a Graphviz-friendly format}
\label{subsec:graphviz_decode}

This function undoes the \verb;graphviz_encode' function (algorithm 
\ref{lst:graphviz_encode}

) and thus converts a Graphviz-friendly std::string to the original human-friend
ly std::string.

\lstinputlisting[
  caption = ,
  label = lst:
]{graphviz_decode.impl}

Decode a std::string from a Graphviz-friendly format to a human-friendly
 format
\index{graphviz decode

\label{lst:graphviz_decode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Check if a std::string is Graphviz-friendly}
\label{subsec:is_graphviz_friendly}

There are pieces where I check if a std::string is Graphviz-friendly.
 This is done only where it matters.
 If it is tested not to matter, \verb;is_graphviz_friendly' is absent.

\lstinputlisting[
  caption = ,
  label = lst:
]{is_graphviz_friendly.impl}

Check if a std::string is Graphviz-friendly
\index{is_graphviz_friendly

\label{lst:is_graphviz_friendly}

\section{...}
Misc functions

These are some function I needed for creating this tutorial.
 Although they are not important for working with graphs, I used these heavily.
 These functions may be compiler-dependent, platform-dependent and/or there
 may be superior alternatives.
 I just add them for completeness.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting a data type as a std::string}
\label{subsec:get_type_name}

This function will only work under GCC.
 I found this code at: 
\begin_inset Flex URL
status collapsed

http://stackoverflow.com/questions/1055452/c-get-name-of-type-in-template

 .
 Thanks to \verb;m-dudley' (Stack Overflow user page at 
\begin_inset Flex URL
status open

http://stackoverflow.com/users/111327/m-dudley

 ).

\lstinputlisting[
  caption = ,
  label = lst:
]{get_type_name.impl}

Getting a data type its name as a std::string
\index{Get type name

\label{lst:get_type_name}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Convert a .dot to .svg}
\label{subsec:convert_dot_to_svg}

All illustrations in this tutorial are created by converting .dot to a .svg
 (\verb;Scalable Vector Graphic') file.
 This function assumes the program \verb;dot' is installed, which is part of
 Graphviz.

\lstinputlisting[
  caption = ,
  label = lst:
]{convert_dot_to_svg.impl}

Convert a .dot file to a .svg
\index{Convert dot to svg

\label{lst:convert_dot_to_svg}

\verb;convert_dot_to_svg' makes a system call to the program \verb;dot' to convert
 the .dot file to an .svg file.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Check if a file exists}
\label{subsec:is_regular_file}

Not the most smart way perhaps, but it does only use the STL.

\lstinputlisting[
  caption = ,
  label = lst:
]{is_regular_file.impl}

Check if a file exists
\index{Is regular file

\label{lst:is_regular_file}

\section{...}
Errors

Some common errors.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Formed reference to void}
\label{subsec:formed_reference_to_void}

This compile-time error occurs when you create a graph without a certain
 property, then subsequently reading that property, as in algorithm 
\ref{lst:formed_reference_to_void}

: 

\lstinputlisting[
  caption = ,
  label = lst:
]{formed_reference_to_void.impl}

Creating the error \verb;formed reference to void;
\index{Formed reference to void

\label{lst:formed_reference_to_void}

In algorithm 
\ref{lst:formed_reference_to_void}

 a graph is created with vertices of no properties.
 Then the names of these vertices, which do not exists, are tried to be
 read.
 If you want to read the names of the vertices, supply a graph that has
 this property.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{No matching function for call to \verb;;clear_out_edges;}
\label{subsec:no_matching_function_for_call_to_clear_out_edges}

This compile-time error occurs when you want to clear the outward edges
 from a vertex in an undirected graph.
 

\lstinputlisting[
  caption = ,
  label = lst:
]{no_matching_function_for_call_to_clear_out_edges.impl}

Creating the error \verb;no matching function for call to clear_out_edges'
\index{No matching function for call to clear_out_edges

\label{lst:no_matching_function_for_call_to_clear_out_edges}

In algorithm 
\ref{lst:no_matching_function_for_call_to_clear_out_edges}

an undirected graph is created, a vertex descriptor is obtained, then itsout
 edges are tried to be cleared.Either use a directed graph (which has out
 edges), or use the \verb;boost::clear_vertex' function instead.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{No matching function for call to \verb;clear_in_edges;}
\label{subsec:no_matching_function_for_call_to_clear_in_edges}

See chapter \ref{subsec:no_matching_function_for_call_to_clear_out_edges}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Undefined reference to boost::detail::graph::read_graphviz_new}
\label{subsec:undefined_reference_to_read_graphviz_new}
\index{read_graphviz_new}
\index{Undefined reference to read_graphviz_new}
\index{read_graphviz_new, undefined reference}

You will have to link
\index{link

 against the Boost.Graph and Boost.Regex libraries.
 In Qt Creator, this is achieved by adding these lines to your Qt Creator
 project file:

\begin{verbatim}\end{verbatim}
LIBS += -lboost_graph -lboost_regex 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Property not found: node_id}
\label{subsec:property_not_found_node_id}
\index{node_id}
\index{Property not found}
\index{Property not found: node_id}

When loading a graph from file (as in chapter 
\ref{subsec:load_undirected_graph_from_dot}

) you will be using boost::read_graphviz
\index{boost::read_graphviz

.
 boost::read_graphviz
\index{boost::read_graphviz

 needs a third argument, of type boost::dynamic_properties
\index{boost::dynamic_properties

.
 When a graph does not have properties, do not use a default constructed
 version, but initialize with \verb;boost::ignore_other_properties;
\index{boost::ignore_other_properties}
as a constructor argument instead. Listing \ref{lst:property_not_found_node_id} shows how to trigger this run-time error.

\lstinputlisting[
  caption = Creating the error 'Property not found: node_id',
  label = lst:property_not_found_node_id
]{property_not_found_node_id.impl}
\index{Property not found: node_id

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Stream zeroes}

When loading a graph from a .dot file, in operator>>, I encountered reading
 zeroes, where I expected an XML formatted string:

\begin{verbatim}
std::istream& ribi::cmap::operator>>(std::istream& is, my_class& any_class)
 noexcept
{
  std::string s;
  is >> s; //s has an XML format
  assert(s != 0);
  any_class = my_class(s);
  return is;
}
\end{verbatim}

This was because I misconfigured the reader.
 I did (heavily simplified code):

\begin{verbatim}
graph load_from_dot(const std::string& dot_filename)
{
  std::ifstream f(dot_filename);
  graph g;
  boost::dynamic_properties dp;
  dp.property(TODO}node_id}, get(boost::vertex_custom_type, g));
  dp.property(TODO}label}, get(boost::vertex_custom_type, g));
  boost::read_graphviz(f,g,dp);
  return g;
}
\end{verbatim}

Where it should have been:

\begin{verbatim}
graph load_from_dot(const std::string& dot_filename)
{
  std::ifstream f(dot_filename);
  graph g;
  boost::dynamic_properties dp(boost::ignore_other_properties);
  dp.property(}label}, get(boost::vertex_custom_type, g));
  boost::read_graphviz(f,g,dp);
  return g;
}
\end{verbatim}

The explanation is that by setting the boost::dynamic_property \verb;node_id'
 to \verb;boost::vertex_custom_type', operator>> will receive the node indices.
 

An alternative, but less clean solution, is to let operator>> ignore the
 node indices:

\begin{verbatim}
std::istream& ribi::cmap::operator>>(std::istream& is, my_class& any_class)
 noexcept
{
  std::string s;
  is >> s; //s has an XML format
  if (!is_xml(s)) { //Ignore node index
    any_class_class = my_class(); 
  }
  else {
    any_class_class = my_class(s);
  }
  return is;
}
\end{verbatim}

