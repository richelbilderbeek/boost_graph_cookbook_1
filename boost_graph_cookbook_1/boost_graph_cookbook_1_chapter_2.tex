%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Building graphs without properties}
\label{sec:Building-graphs-without-properties}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Boost.Graph is about creating graphs.
In this chapter we create the simplest of graphs, in which edges and nodes
have no properties (e.g. having a name).

Still, there are two types of graphs that can be constructed: undirected
and directed graphs.
The difference between directed and undirected graphs is in the edges:
in an undirected graph, 
an edge connects two vertices without any directionality, as displayed
in figure \ref{fig:undirected_graph_example}.

In a directed graph, an edge goes from a certain vertex, 
its source, to another (which may actually be the same), its target.
A directed graph is shown in figure \ref{fig:directed_graph_example}.

\begin{figure}
  \begin{tikzpicture}
    \draw[thick] 
      (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 
      -- (5,2) node[draw=black,fill=white,shape=circle,text=white] {} 
      -- (10,1) node[draw=black,fill=white,shape=circle,text=white] {} 
    ;
  \end{tikzpicture}
  \caption{Example of an undirected graph}
  \label{fig:undirected_graph_example}
\end{figure}

\begin{figure}
  \begin{tikzpicture}
    \SetGraphUnit{5}
    \tikzset{VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=white} }
    \Vertex{A}
    \EA(A){B}
    \EA(B){C}
    \tikzset{EdgeStyle/.append style = {->, bend left} }
    \Edge[](A)(B)
    \Edge[](B)(A)
    \Loop[dist = 4cm, dir = NO](A.west)
    \tikzset{EdgeStyle/.append style = {bend left = 0} }
    \Edge[](C)(B)   
  \end{tikzpicture}
  \caption{Example of a directed graph}
  \label{fig:directed_graph_example}
\end{figure}

In this chapter, we will build two directed and two undirected graphs:

\begin{itemize}
  \item An empty (directed) graph, which is the default type: 
    see chapter \ref{subsec:create_empty_directed_graph}
  \item An empty (undirected) graph: 
    see chapter \ref{subsec:create_empty_undirected_graph}
  \item A two-state Markov chain, a directed graph with two vertices 
    and four edges:
    see chapter \ref{subsec:create_markov_chain_graph}
  \item $K_{2}$, an undirected graph with two vertices and one edge, 
    see chapter \ref{subsec:create_k2_graph}
\end{itemize}


Creating an empty graph may sound trivial, it is not, thanks to the versatility
of the Boost.Graph library.

In the process of creating graphs, some basic (sometimes bordering trivial)
functions are encountered:

\begin{itemize}
  \item Counting the number of vertices, 
    see chapter \ref{subsec:get_n_vertices}
  \item Counting the number of edges,
     see chapter \ref{subsec:get_n_edges}
  \item Adding a vertex,
     see chapter \ref{subsec:add_vertex}
  \item Getting all vertices,
     see chapter \ref{subsec:get_vertices}
  \item Getting all vertex descriptors,
     see chapter \ref{subsec:get_vertex_descriptors}
  \item Adding an edge,
     see chapter \ref{subsec:add_edge}
  \item Getting all edges,
    see chapter \ref{subsec:get_edge_iterators}
  \item Getting all edge descriptors,
    see chapter \ref{subsec:get_edge_descriptors}
\end{itemize}

These functions are mostly there for completion and showing which data types
are used.

The chapter also introduces some important concepts:

\begin{itemize}
  \item Vertex descriptors,
    see chapter \ref{subsec:Vertex-descriptors}
  \item Edge insertion result,
    see chapter \ref{subsec:boost::add_edge result}
  \item Edge descriptors,
    see chapter \ref{subsec:Edge-descriptors}
\end{itemize}

After this chapter you may want to:

\begin{itemize}
  \item Building graphs with named vertices, 
    see chapter \ref{sec:Building-graphs-with-named-vertices}
  \item Building graphs with bundled vertices, 
    see chapter \ref{sec:Building-graphs-with-bundled-vertices}
  \item Building graphs with custom vertices,
    see chapter \ref{sec:Building-graphs-with-custom-properties}
  \item Building graphs with a graph name,
    see chapter \ref{sec:Building-graphs-with-a-graph-name}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating an empty (directed) graph}
\label{subsec:create_empty_directed_graph}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's create an empty graph! 
Listing \ref{lst:create_empty_directed_graph} 
shows the function to create an empty graph.

\lstinputlisting[
  caption = Creating an empty (directed) graph,
  label = lst:create_empty_directed_graph
]{create_empty_directed_graph.impl}

The code consists out of an #include and a function definition.
The \verb;#include; tells the compiler 
to read the header file \verb;adjacency_list.hpp;.
A header file (often with a \verb;.h; or \verb;.hpp; extension) 
contains class and functions declarations and/or definitions.
The header file \verb;adjacency_list.hpp; contains the 
\verb;boost::adjacency_list; class definition.
Without including this file, you will get compile errors like 
\verb;definition of boost::adjacency_list unknown;
\footnote{
  In practice, these compiler error messages will be longer, bordering the unreadable
}. 

The function \verb;create_empty_directed_graph; has:

\begin{itemize}
  \item a return type: 
    The return type is \verb;boost::adjacency_list<>;, 
    that is a \verb;boost::adjacency_list; 
    with all template arguments set at their defaults
  \item a \verb;noexcept; specification: 
    the function should not throw
    \footnote{
      if the function would throw because it cannot allocate this little piece
      of memory, you are already in big trouble
    }, so it is preferred to mark it \verb;noexcept; 
    (\cite{stroustrup2013}, chapter 13.7)
  \item a function body: 
    all the function body does is implicitly create its return
    type by using the \verb;{};.
    An alternative syntax would be \verb;return boost::adjacency_list<>();, 
    which is needlessly longer
\end{itemize}

Listing \ref{lst:create_empty_directed_graph_demo}
demonstrates the \verb;create_empty_directed_graph; function.
This demonstration is embedded within a Boost.Test unit test case.
It includes a Boost.Test header to allow to use the Boost.Test framework.
Additionally, a header file is included with the same name as the function
\footnote{
  I do not think it is important to have creative names
}.
This allows use to be able to use the function.
The test case creates an empty graph and stores it.
Instead of specifying the data type explicitly, 
\verb;auto; \index{auto} is used (this is preferred, \cite{stroustrup2013}
chapter 31.6), which lets the compiler figure out the type itself.

\lstinputlisting[
  caption = Demonstration of create\_empty\_directed\_graph,
  label = lst:create_empty_directed_graph_demo
]{create_empty_directed_graph_demo.impl}

Congratulations, you've just created a 
\verb;boost::adjacency_list; \index{boost::adjacency\_list}
with its default template arguments.
The \verb;boost::adjacency_list; is the most commonly used graph type, the other
is the 
\verb;boost::adjacency_matrix; \index{boost::adjacency\_matrix}.

We do not do anything with it yet, but still, you've just created a graph,
in which:

\begin{itemize}
  \item The out edges and vertices are stored in a \verb;std::vector; \index{std::vector}
  \item The edges have a direction
  \item The vertices, edges and graph have no properties
  \item The edges are stored in a \verb;std::list; \index{std::list}
\end{itemize}

It stores its edges, out edges and vertices in two different STL \index{STL}
\footnote{
  Standard Template Library, the standard library
}
containers.
std::vector \index{std::vector} is the container you should use by default (
  \cite{stroustrup2013}, chapter 31.6, 
  \cite{sutter_and_alexandrescu2004}, chapter 76
), as it has constant time look-up and back insertion.
The \verb;std::list; \index{std::list}
is used for storing the edges, as it is better suited at inserting elements
at any position.

I use \verb;const; \index{const} to store the empty graph as we do not modify it.
Correct use of \verb;const; is called const-correct.
Prefer to be const-correct \index{const-correctness}
(
  \cite{stroustrup1997}, chapter 7.9.3, 
  \cite{stroustrup2013}, chapter 12.7, 
  \cite{meyers2005effective}, item 3, 
  \cite{hollingworth2000cpp_builder_dev_guide}, chapter 3, 
  \cite{sutter_and_alexandrescu2004}, item 15, 
  \cite{cline1998cpp_faqs}, FAQ 14.05, 
  \cite{eckel2002thinking_cpp}, item 8, 
  \cite{lakos1996large}, 9.1.6
).

