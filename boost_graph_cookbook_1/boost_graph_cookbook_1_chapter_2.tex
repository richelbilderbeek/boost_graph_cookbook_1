%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Building graphs without properties}
\label{sec:Building-graphs-without-properties}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Boost.Graph is about creating graphs.
In this chapter we create the simplest of graphs, in which edges and nodes
have no properties (e.g. having a name).

Still, there are two types of graphs that can be constructed: undirected
and directed graphs.
The difference between directed and undirected graphs is in the edges:
in an undirected graph, 
an edge connects two vertices without any directionality, as displayed
in figure \ref{fig:undirected_graph_example}.

In a directed graph, an edge goes from a certain vertex, 
its source, to another (which may actually be the same), its target.
A directed graph is shown in figure \ref{fig:directed_graph_example}.

\begin{figure}
  \begin{tikzpicture}
    \draw[thick] 
      (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 
      -- (5,2) node[draw=black,fill=white,shape=circle,text=white] {} 
      -- (10,1) node[draw=black,fill=white,shape=circle,text=white] {} 
    ;
  \end{tikzpicture}
  \caption{Example of an undirected graph}
  \label{fig:undirected_graph_example}
\end{figure}

\begin{figure}
  \begin{tikzpicture}
    \SetGraphUnit{5}
    \tikzset{VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=white} }
    \Vertex{A}
    \EA(A){B}
    \EA(B){C}
    \tikzset{EdgeStyle/.append style = {->, bend left} }
    \Edge[](A)(B)
    \Edge[](B)(A)
    \Loop[dist = 4cm, dir = NO](A.west)
    \tikzset{EdgeStyle/.append style = {bend left = 0} }
    \Edge[](C)(B)   
  \end{tikzpicture}
  \caption{Example of a directed graph}
  \label{fig:directed_graph_example}
\end{figure}

In this chapter, we will build two directed and two undirected graphs:

\begin{itemize}
  \item An empty (directed) graph, which is the default type: 
    see chapter \ref{subsec:create_empty_directed_graph}
  \item An empty (undirected) graph: 
    see chapter \ref{subsec:create_empty_undirected_graph}
  \item A two-state Markov chain, a directed graph with two vertices 
    and four edges:
    see chapter \ref{subsec:create_markov_chain_graph}
  \item $K_{2}$, an undirected graph with two vertices and one edge, 
    see chapter \ref{subsec:create_k2_graph}
\end{itemize}


Creating an empty graph may sound trivial, it is not, thanks to the versatility
of the Boost.Graph library.

In the process of creating graphs, some basic (sometimes bordering trivial)
functions are encountered:

\begin{itemize}
  \item Counting the number of vertices, 
    see chapter \ref{subsec:get_n_vertices}
  \item Counting the number of edges,
     see chapter \ref{subsec:get_n_edges}
  \item Adding a vertex,
     see chapter \ref{subsec:add_vertex}
  \item Getting all vertices,
     see chapter \ref{subsec:get_vertices}
  \item Getting all vertex descriptors,
     see chapter \ref{subsec:get_vertex_descriptors}
  \item Adding an edge,
     see chapter \ref{subsec:add_edge}
  \item Getting all edges,
    see chapter \ref{subsec:get_edge_iterators}
  \item Getting all edge descriptors,
    see chapter \ref{subsec:get_edge_descriptors}
\end{itemize}

These functions are mostly there for completion and showing which data types
are used.

The chapter also introduces some important concepts:

\begin{itemize}
  \item Vertex descriptors,
    see chapter \ref{subsec:Vertex-descriptors}
  \item Edge insertion result,
    see chapter \ref{subsec:boost::add_edge result}
  \item Edge descriptors,
    see chapter \ref{subsec:Edge-descriptors}
\end{itemize}

After this chapter you may want to:

\begin{itemize}
  \item Building graphs with named vertices, 
    see chapter \ref{sec:Building-graphs-with-named-vertices}
  \item Building graphs with bundled vertices, 
    see chapter \ref{sec:Building-graphs-with-bundled-vertices}
  \item Building graphs with custom vertices,
    see chapter \ref{sec:Building-graphs-with-custom-properties}
  \item Building graphs with a graph name,
    see chapter \ref{sec:Building-graphs-with-a-graph-name}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating an empty (directed) graph}
\label{subsec:create_empty_directed_graph}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's create an empty graph! 
Listing \ref{lst:create_empty_directed_graph} 
shows the function to create an empty graph.

\lstinputlisting[
  caption = Creating an empty (directed) graph,
  label = lst:create_empty_directed_graph
]{create_empty_directed_graph.impl}

The code consists out of an #include and a function definition.
The \verb;#include; tells the compiler 
to read the header file \verb;adjacency_list.hpp;.
A header file (often with a \verb;.h; or \verb;.hpp; extension) 
contains class and functions declarations and/or definitions.
The header file \verb;adjacency_list.hpp; contains the 
\verb;boost::adjacency_list; class definition.
Without including this file, you will get compile errors like 
\verb;definition of boost::adjacency_list unknown;
\footnote{
  In practice, these compiler error messages will be longer, bordering the unreadable
}. 

The function \verb;create_empty_directed_graph; has:

\begin{itemize}
  \item a return type: 
    The return type is \verb;boost::adjacency_list<>;, 
    that is a \verb;boost::adjacency_list; 
    with all template arguments set at their defaults
  \item a \verb;noexcept; specification: 
    the function should not throw
    \footnote{
      if the function would throw because it cannot allocate this little piece
      of memory, you are already in big trouble
    }, so it is preferred to mark it \verb;noexcept; 
    (\cite{stroustrup2013}, chapter 13.7)
  \item a function body: 
    all the function body does is implicitly create its return
    type by using the \verb;{};.
    An alternative syntax would be \verb;return boost::adjacency_list<>();, 
    which is needlessly longer
\end{itemize}

Listing \ref{lst:create_empty_directed_graph_demo}
demonstrates the \verb;create_empty_directed_graph; function.
This demonstration is embedded within a Boost.Test unit test case.
It includes a Boost.Test header to allow to use the Boost.Test framework.
Additionally, a header file is included with the same name as the function
\footnote{
  I do not think it is important to have creative names
}.
This allows use to be able to use the function.
The test case creates an empty graph and stores it.
Instead of specifying the data type explicitly, 
\verb;auto; \index{auto} is used (this is preferred, \cite{stroustrup2013}
chapter 31.6), which lets the compiler figure out the type itself.

\lstinputlisting[
  caption = Demonstration of create\_empty\_directed\_graph,
  label = lst:create_empty_directed_graph_demo
]{create_empty_directed_graph_demo.impl}

Congratulations, you've just created a 
\verb;boost::adjacency_list; \index{boost::adjacency\_list}
with its default template arguments.
The \verb;boost::adjacency_list; is the most commonly used graph type, the other
is the 
\verb;boost::adjacency_matrix; \index{boost::adjacency\_matrix}.

We do not do anything with it yet, but still, you've just created a graph,
in which:

\begin{itemize}
  \item The out edges and vertices are stored in a \verb;std::vector; \index{std::vector}
  \item The edges have a direction
  \item The vertices, edges and graph have no properties
  \item The edges are stored in a \verb;std::list; \index{std::list}
\end{itemize}

It stores its edges, out edges and vertices in two different STL \index{STL}
\footnote{
  Standard Template Library, the standard library
}
containers.
std::vector \index{std::vector} is the container you should use by default (
  \cite{stroustrup2013}, chapter 31.6, 
  \cite{sutter_and_alexandrescu2004}, chapter 76
), as it has constant time look-up and back insertion.
The \verb;std::list; \index{std::list}
is used for storing the edges, as it is better suited at inserting elements
at any position.

I use \verb;const; \index{const} to store the empty graph as we do not modify it.
Correct use of \verb;const; is called const-correct.
Prefer to be const-correct \index{const-correctness}
(
  \cite{stroustrup1997}, chapter 7.9.3, 
  \cite{stroustrup2013}, chapter 12.7, 
  \cite{meyers2005effective}, item 3, 
  \cite{hollingworth2000cpp_builder_dev_guide}, chapter 3, 
  \cite{sutter_and_alexandrescu2004}, item 15, 
  \cite{cline1998cpp_faqs}, FAQ 14.05, 
  \cite{eckel2002thinking_cpp}, item 8, 
  \cite{lakos1996large}, 9.1.6
).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating an empty undirected graph}
\label{subsec:create_empty_undirected_graph}
\index{Create an empty graph}
\index{Empty graph, create}
\index{Create empty undirected graph}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's create another empty graph! This time, we even make it undirected!
Listing \ref{lst:create_empty_undirected_graph}
shows how to create an undirected graph.

\lstinputlisting[
  caption = Creating an empty undirected graph,
  label = lst:create_empty_undirected_graph
]{create_empty_undirected_graph.impl}

This algorithm differs from the \verb;create_empty_directed_graph;
function (algorithm 
\ref{lst:create_empty_directed_graph}
) 
in that there are three template arguments that need to be specified in
the creation of the boost::adjacency_list:

\begin{itemize}
  \item the first \verb;boost::vecS; \index{boost::vecS}: 
    select (that is what the \verb;S; \index{S}
    means) that out edges are stored in a std::vector.
    This is the default way.
  \item
    the second \verb;boost::vecS; \index{boost::vecS}: 
    select that the graph vertices are stored in a std::vector.
    This is the default way.
  \item
    \verb;boost::undirectedS; \index{boost::undirectedS}: 
    select that the graph is undirected.
    This is all we needed to change.
    By default, this argument is boost::directed \index{boost::directedS}
\end{itemize}

Listing \ref{lst:create_empty_undirected_graph_demo}
demonstrates the \verb;create_empty_undirected_graph; function.

\lstinputlisting[
  caption = Demonstration of create\_empty\_undirected\_graph,
  label = lst:create_empty_undirected_graph_demo
]{create_empty_undirected_graph_demo.impl}

Congratulations, with algorithm \ref{lst:create_empty_undirected_graph_demo}, 
you have just created an undirected graph in which:

\begin{itemize}
  \item The out edges and vertices are stored in a std::vector
  \item The graph is undirected
  \item Vertices, edges and graph have no properties
  \item Edges are stored in a std::list
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Counting the number of vertices}
\label{subsec:get_n_vertices}
\index{Vertices, counting}
\index{Counting the number of vertices}
\index{Number of vertices, get}
\index{Get n vertices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's count all zero vertices of an empty graph!

\lstinputlisting[
  caption = Count the number of vertices,
  label = lst:get_n_vertices
]{get_n_vertices.impl}

The function \verb;get_n_vertices; takes the result of \verb;boost::num_vertices;
\index{boost::num_vertices}, converts it to int and checks if there was conversion error.
We do so, as one should prefer using signed data types over unsigned ones
in an interface (\cite{lakos1996large}, chapter 9.2.2).
To do so, in the function body its first statement, 
the unsigned long \index{unsigned long}
produced by \verb;boost::num_vertices; \index{boost::num\_vertices}
get converted to an int using a \verb;static_cast; \index{static\_cast}.

Using an unsigned integer over a (signed) integer for the sake of gaining
that one more bit (\cite{stroustrup1997}, chapter 4.4) should be avoided.
The integer \verb;n; is initialized using list-initialization, which is preferred
over the other initialization syntaxes (\cite{stroustrup2013}, chapter 17.7.6).

The \verb;assert; checks if the conversion back to unsigned long re-creates the
original value, to check if no information has been lost.
If information is lost, the program crashes.
Use \verb;assert; \index{assert} extensively 
(\cite{stroustrup1997}, chapter 24.5.18, 
\cite{stroustrup2013}, chapter 30.5, 
\cite{sutter_and_alexandrescu2004}. chapter 68, 
\cite{mcconnell2004code}, chapter 8.2, 
\cite{liberty2001sams}, hour 24, 
\cite{lakos1996large}, chapter 2.6).

The function \verb;get_n_vertices; is demonstrated in algorithm 
\ref{lst:get_n_vertices_demo}, 
to measure the number of vertices of both the directed and undirected
graph we are already able to create.

\lstinputlisting[
  caption = Demonstration of the get\_n\_vertices function,
  label = lst:get_n_vertices_demo
]{get_n_vertices_demo.impl}

Note that the type of graph does not matter here.
One can count the number of vertices of every graph, as all graphs have
vertices.
Boost.Graph is very good at detecting operations that are not allowed, during
compile time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Counting the number of edges}
\label{subsec:get_n_edges}
\index{Edges, counting}
\index{Counting the number of edges}
\index{Number of edges, get}
\index{Get n edges}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's count all zero edges of an empty graph!

This is very similar to the previous chapter, 
only it uses \verb;boost::num_edges; \index{boost::num_edges}
instead:

\lstinputlisting[
  caption = Count the number of edges,
  label = lst:get_n_edges
]{get_n_edges.impl}

This code is similar to the \verb;get_n_vertices; 
function (algorithm \ref{lst:get_n_vertices}, see rationale there) 
except \verb;boost::num_edges; \index{boost::num_edges}
is used, instead of \verb;boost::num_vertices;, 
which also returns an unsigned long.

The function \verb;get_n_edges; is demonstrated in algorithm 
\ref{lst:get_n_edges_demo}, 
to measure the number of edges of an empty directed and undirected graph.

\lstinputlisting[
  caption = Demonstration of the get\_n\_edges function,
  label = lst:get_n_edges_demo
]{get_n_edges_demo.impl}

